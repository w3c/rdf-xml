<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>RDF 1.2 XML Syntax</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  <script src="./common/local-biblio.js" class="remove"></script>
  <script src="./common/fixup.js" class="remove"></script>
  <script class='remove'>
    var respecConfig = {
      localBiblio:          {...localBibliography,
        /// Hack temporary bib entry for SAX
        ...{
          SAX: {
            title: "SAX – The Simple API for XML",
            href: "https://accu.org/journals/overload/7/34/cornish_515/",
            authors: ["Steve Cornish"],
            date: "October 1999",
          }
        }
      },
      specStatus:           "ED",
      edDraftURI:           "https://w3c.github.io/rdf-xml/spec/",
      shortName:            "rdf12-xml",
      testSuiteURI:         "https://w3c.github.io/rdf-tests/rdf-xml/",
      copyrightStart:       "2004",

      previousPublishDate:  "2014-02-25",
      previousMaturity:     "REC",
      prevRecShortname:     "rdf-syntax-grammar",

      editors: [
        { name: "Gregg Kellogg", w3cid: "44770" },
      ],

      formerEditors:  [
        { name: "Fabien Gandon" },
        { name: "Guus Schreiber" },
        { name: "Dave Beckett"},
        { name: "Ora Lassilla"},
        { name: "Ralph Swick"},
      ],

      authors: [
        { name: "Dave Beckett"}
      ],

      xref: [ "RDF11-CONCEPTS" ], // Fixme: change to RDF12-CONCEPTS
      github: "https://github.com/w3c/rdf-xml/",
      group:           "rdf-star",
      doJsonLd:     true,
      wgPublicList: "public-rdf-star-wg"
    };
  </script>
  <style>
   figure { width: 76% ;  text-align: center}
   table { border-collapse:collapse; }
   table, td, th { border:1px solid black; }
   caption { font-weight: bold; text-align: left ; }
   .hl-bold { font-weight: bold; color: #0a3; }
   code {color: #ff4500;}  /* Old W3C Style */
  </style>
</head>

<body>

<section id="abstract">
  <p>This document defines an XML
    syntax for RDF called RDF/XML in terms of
    Namespaces in XML, the XML Information Set
    and XML Base.</p>

</section>

<section id="sotd">
  <p>This document is a part of the RDF 1.2 document suite. The
    document defines the RDF/XML syntax,
    a concrete syntax for RDF [[RDF12-CONCEPTS]].</p>

  <p>There have been no substantive changes to this document since [[rdf-syntax-grammar]].
    Minor editorial changes, if any, are
    detailed in <a href="#changes-12" class="sectionRef"></a>.</p>
  
  <section id="related" data-include="./common/related.html"></section>
 </section>

<section id="section-Introduction">
  <h2>Introduction</h2>

  <p>This document defines the XML [[XML10]] syntax for RDF graphs. </p>

  <p>This document revises the original RDF/XML grammar [[RDF-SYNTAX-GRAMMAR-19990222]]
    in terms of XML Information Set [[XML-INFOSET]] information items which moves
    away from the rather low-level details of XML, such as particular
    forms of empty elements.  This allows the grammar to be more
    precisely recorded and the mapping from the XML syntax to the RDF
    Graph more clearly shown.  The mapping to the RDF graph is done by
    emitting statements in the N-Triples [[RDF12-N-TRIPLES]] format. </p>

  <ul>
    <li>A document describing the basic concepts underlying RDF, as
      well as abstract syntax ("RDF Concepts and Abstract Syntax")
      [[RDF12-CONCEPTS]]</li>
    <li>A document describing the formal model-theoretic semantics
      of RDF ("RDF Semantics") [[RDF12-SEMANTICS]]</li>
    <li>Specifications of concrete syntaxes for RDF:
      <ul>
        <li>Turtle [[RDF12-TURTLE]] and TriG [[RDF12-TRIG]]</li>
        <li>JSON-LD [[JSON-LD11]] (JSON based)</li>
        <li>RDFa [[RDFA-PRIMER]] (for HTML embedding)</li>
        <li>N-Triples [N-TRIPLES] and N-Quads [N-QUADS] (line-based exchange formats)</li>
      </ul>
    </li>
    <li>A document describing RDF Schema [[RDF-SCHEMA]], which
      provides a data-modeling vocabulary for RDF data. </li>
  </ul>
  <p>For a longer introduction to the RDF/XML syntax with a historical
    perspective, see "RDF: Understanding the Striped RDF/XML
    Syntax" [[STRIPEDRDF]].</p>

</section>


<!-- FIRST PART : THE SYNTAX -->

<section id="section-Syntax">

  <h2>An XML Syntax for RDF</h2>
  <p>This section introduces the RDF/XML syntax, describes how it
   encodes RDF graphs and explains this with examples.  If there is any
   conflict between this informal description and the formal description
   of the syntax and grammar in sections
   <a href="#section-Data-Model" class="sectionRef"></a> and
   <a href="#section-Infoset-Grammar" class="sectionRef"></a>,
   the latter two sections take precedence.
  </p>

    <!-- intro -->
  <section id="section-Syntax-intro">
    <h3>Introduction</h3>

    <p>The RDF Concepts and Abstract Syntax document [[RDF12-CONCEPTS]]
    defines the RDF Graph data model and the
    RDF Graph abstract syntax.
    Along with the RDF Semantics [[RDF12-SEMANTICS]]
    this provides an abstract syntax with a formal semantics for it.
    The RDF graph has <em>nodes</em>
    and labeled directed <em>arcs</em>
    that link pairs of nodes and this is represented as a set of
    RDF triples
    where each triple contains a
    <em>subject node</em>, <em>predicate</em> and <em>object node</em>.
    Nodes are IRIs, literals, or blank nodes.
    Blank nodes may be given
    a document-local identifier called a
    blank node identifier.
    Predicates are IRIs
    and can be interpreted as either a relationship between the two
    nodes or as defining an attribute value (object node) for some
    subject node.</p>

    <p>In order to encode the graph in XML, the nodes and predicates have to be
    represented in XML terms &mdash; element names, attribute names, element contents
    and attribute values.
    RDF/XML uses XML <a data-cite="XML-NAMES#NT-QName">QNames</a>
    as defined in Namespaces in XML [[XML-NAMES]] to represent IRIs.
    All QNames have a <a data-cite="XML-NAMES#dt-NSName">namespace name</a> which is an IRI
    and a short
    <a data-cite="XML-NAMES#NT-LocalPart">local name</a>.
    In addition, QNames can either have a short
    <a data-cite="XML-NAMES#NT-Prefix">prefix</a>
    or be declared with the default namespace declaration and have none (but
    still have a namespace name)</p>

    <p>The IRI represented by a QName is determined by appending the
    <a data-cite="XML-NAMES#NT-LocalPart">local name</a>
    part of the QName after the
    <a data-cite="XML-NAMES#dt-NSName">namespace name</a> (IRI) part of the QName.
    This is used to shorten the IRI
    of all predicates and some nodes.
    IRIs identifying
    subject and object nodes can also be stored as XML attribute values.
    RDF literals
    which can only be object nodes,
    become either XML element text content or XML attribute values.</p>

    <p>A graph can be considered a collection of paths of the form node,
    predicate arc, node, predicate arc, node, predicate arc, ... node
    which cover the entire graph. In RDF/XML these turn into sequences of
    elements inside elements which alternate between elements for nodes
    and predicate arcs.  This has been called a series of node/arc
    stripes.  The node at the start of the sequence turns into the
    outermost element, the next predicate arc turns into a child element,
    and so on.  The stripes generally start at the top of an RDF/XML
    document and always begin with nodes.
    </p>

    <p>Several RDF/XML examples are given in the following sections
    building up to complete RDF/XML documents.  <a href="#example7">Example 7</a>
    is the first complete RDF/XML document.</p>
  </section>

  <!-- node and property elements -->
  <section id="section-Syntax-node-property-elements">
    <h3>Node Elements and Property Elements</h3>

    <figure id="figure1">
      <!-- Source for this file is at https://docs.google.com/drawings/d/1IJuh-WWpk_jIgzNpnnZN6d-ezTFv9k03o59GQBIeo58 -->
      <img src="figure1.svg" style="width: 100%" aria-describedby="figure1-alt"
         alt="Graph for RDF/XML Example 4." />
      <figcaption id="figure1-alt">Graph for RDF/XML Example
        described in <a href="#example4"></a>.
      </figcaption>
    </figure>

    <p>An RDF graph is given in <a href="#figure1">Figure 1</a>
      where the nodes are represented as ovals and contain their
      IRIs where they have them, all the predicate arcs are labeled with
      IRIs and string literals nodes have been written in rectangles.</p>

    <p>If we follow one node, predicate arc ... , node path through the
      graph shown in <a href="#figure2">Figure 2</a>:</p>

    <figure id="figure2">
      <!-- Source for this file is at https://docs.google.com/drawings/d/1oQjG8DyfGr33UnaCrS7nC96JMt3NI7Jv2v5LfLUZcYE -->
      <img src="figure2.svg" style="width: 100%" aria-describedby="figure2-alt"
         alt="One path through the graph for RDF/XML Example 4." />
      <figcaption id="figure2-alt">One Path Through the Graph
        described in <a href="#example4"></a>
        highlighting the path from `&lt;http://www.w3.org/TR/rdf-syntax-grammar>`
        to `&lt;http://purl.org/net/dajobe>`.
        Elements along the path are marked in <strong>bold text</strong>.
      </figcaption>
    </figure>

    <p>The left hand side of the <a href="#figure2">Figure 2</a>
      graph corresponds to the node/predicate arc stripes:</p>

    <ol>
      <li>Node with IRI <code>http://www.w3.org/TR/rdf-syntax-grammar</code></li>
      <li>Predicate Arc labeled with IRI <code>http://example.org/terms/editor</code></li>
      <li>Node with no IRI</li>
      <li>Predicate Arc labeled with IRI  <code>http://example.org/terms/homePage</code></li>
      <li>Node with IRI <code>http://purl.org/net/dajobe/</code></li>
    </ol>

    <p>In RDF/XML, the sequence of 5 nodes and predicate arcs on
      the left hand side of <a href="#figure2">Figure 2</a> corresponds to
      the usage of five XML elements of two types, for the graph nodes and
      predicate arcs. These are conventionally called <em>node elements</em> and
      <em>property elements</em> respectively.  In the striping shown in
      <a href="#example1">Example 1</a>, <code>rdf:Description</code> is the
      node element (used three times for the three nodes) and
      <code>ex:editor</code> and <code>ex:homePage</code> are the two
      property elements.</p>

    <pre class="example rdf" id="example1"
         data-transform="updateExample"
         title="Striped RDF/XML (nodes and predicate arcs)">
      <!--
      ****<rdf:Description>****
      <ex:editor>
        ****<rdf:Description>****
          <ex:homePage>
            <rdf:Description>
            </rdf:Description>
          </ex:homePage>
        ****</rdf:Description>****
      </ex:editor>
      ****</rdf:Description>****
      -->
    </pre>

    <p>The <a href="#figure2">Figure 2</a> graph consists of some nodes
      that are IRIs (and others that are not) and this can be added
      to the RDF/XML using the <code>rdf:about</code> attribute on node
      elements to give the result in <a href="#example2">Example 2</a>:</p>

    <pre class="example rdf" id="example2"
       data-transform="updateExample"
       title="Node Elements with IRIs added">
    <!--
    <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
      <ex:editor>
        <rdf:Description>
          <ex:homePage>
            <rdf:Description rdf:about="http://purl.org/net/dajobe/">
            </rdf:Description>
          </ex:homePage>
        </rdf:Description>
      </ex:editor>
    </rdf:Description>
    -->
    </pre>

    <p>Adding the other two paths through the <a href="#figure1">Figure 1</a>
      graph to the RDF/XML in
      <a href="#example2">Example 2</a>
      gives the result in <a href="#example3">Example 3</a>
      (this example fails to show that the blank node is
      shared between the two paths,
      see <a href="#section-Syntax-blank-nodes" class="sectionRef"></a>):</p>

    <pre class="example rdf" id="example3"
       data-transform="updateExample"
       title="Complete description of all graph paths">
      <!--
      <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
        <ex:editor>
          <rdf:Description>
            <ex:homePage>
              <rdf:Description rdf:about="http://purl.org/net/dajobe/">
              </rdf:Description>
            </ex:homePage>
          </rdf:Description>
        </ex:editor>
      </rdf:Description>

      <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
        <ex:editor>
          <rdf:Description>
            <ex:fullName>Dave Beckett</ex:fullName>
          </rdf:Description>
        </ex:editor>
      </rdf:Description>

      <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
        <dc:title>RDF 1.2 XML Syntax</dc:title>
      </rdf:Description>
      -->
    </pre>
  </section>

  <!-- multiple properties -->
  <section id="section-Syntax-multiple-property-elements" >
    <h3>Multiple Property Elements</h3>

    <p>There are several abbreviations that can be used to make common
    uses easier to write down.  In particular, it is common that a
    subject node in the RDF graph has multiple outgoing predicate arcs.  RDF/XML
    provides an abbreviation for the corresponding syntax when a node
    element about a resource has multiple property elements. This can be
    abbreviated by using multiple child property elements inside the node
    element describing the subject node.</p>

    <p>Taking <a href="#example3">Example 3</a>, there  are
    two node elements that can take multiple property elements.
    The subject node with IRI
    <code>http://www.w3.org/TR/rdf-syntax-grammar</code>
    has property elements <code>ex:editor</code> and <code>ex:title</code>
    and the node element for the blank node can take <code>ex:homePage</code>
    and <code>ex:fullName</code>.  This abbreviation
    gives the result shown in <a href="#example4">Example 4</a>
    (this example does show that there is a single blank node):</p>

    <pre class="example rdf" id="example4"
          data-transform="updateExample"
          title="Using multiple property elements on a node element">
      <!--
      <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
        <ex:editor>
          <rdf:Description>
            <ex:homePage>
              <rdf:Description rdf:about="http://purl.org/net/dajobe/">
              </rdf:Description>
            </ex:homePage>
            <ex:fullName>Dave Beckett</ex:fullName>
          </rdf:Description>
        </ex:editor>
        <dc:title>RDF 1.2 XML Syntax</dc:title>
      </rdf:Description>
      -->
    </pre>

  </section>

  <!-- empty property elements -->
  <section id="section-Syntax-empty-property-elements">
    <h3>Empty Property Elements</h3>

    <p>When a predicate arc in an RDF graph points to an object node which has no
    further predicate arcs, which appears in RDF/XML as an empty node element
    <code>&lt;rdf:Description rdf:about="..."&gt;</code>
    <code>&lt;/rdf:Description&gt;</code>
    (or <code>&lt;rdf:Description rdf:about="..." /&gt;</code>)
    this form can be shortened.  This is done by using the
    IRI of the object node as the value of an XML attribute <code>rdf:resource</code>
    on the containing property element and making the property element empty.
    </p>

    <p>In this example, the property element <code>ex:homePage</code>
    contains an empty node element with the IRI
    <code>http://purl.org/net/dajobe/</code>.  This can be replaced with
    the empty property element form giving the result shown in
    <a href="#example5">Example 5</a>:</p>

    <pre class="example rdf" id="example5"
         data-transform="updateExample"
         title="Empty property elements">
       <!--
      <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
        <ex:editor>
          <rdf:Description>
            <ex:homePage rdf:resource="http://purl.org/net/dajobe/"/>
            <ex:fullName>Dave Beckett</ex:fullName>
          </rdf:Description>
        </ex:editor>
        <dc:title>RDF 1.2 XML Syntax</dc:title>
      </rdf:Description>
       -->
    </pre>

  </section>

  <!-- empty property attributes -->
  <section id="section-Syntax-property-attributes">
    <h3>Property Attributes</h3>

    <p>When a property element's content is string literal,
    it may be possible to use it as an XML attribute on the
    containing node element.
    This can be done for multiple properties on the same node element
    only if the property element name is not repeated
    (required by XML &mdash; attribute names are unique on an XML element)
    and any in-scope <code>xml:lang</code> on the
    property element's string literal (if any) are the same
    (see <a href="#section-Syntax-languages" class="sectionRef"></a>)
    This abbreviation is known as a <em>Property Attribute</em>
    and can be applied to any node element.</p>

    <p>This abbreviation can also be used when the property element is
    <code>rdf:type</code> and it has an <code>rdf:resource</code> attribute
    the value of which is interpreted as a
    IRI object node.</p>

    <p>In <a href="#example5">Example 5</a>:,
    there are two property elements with string literal content,
    the <code>dc:title</code> and <code>ex:fullName</code>
    property elements.  These can be replaced with property attributes
    giving the result shown in <a href="#example6">Example 6</a>:</p>

    <pre class="example rdf" id="example6"
         data-transform="updateExample"
         title="Replacing property elements with string literal content into property attributes">
      <!--
      <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar"
                 dc:title="RDF 1.2 XML Syntax">
        <ex:editor>
          <rdf:Description ex:fullName="Dave Beckett">
            <ex:homePage rdf:resource="http://purl.org/net/dajobe/"/>
          </rdf:Description>
        </ex:editor>
      </rdf:Description>
      -->
    </pre>

  </section>

  <!-- complete rdf/xml document -->
  <section id="section-Syntax-complete-document">
    <h3>Completing the Document: Document Element and XML Declaration</h3>

    <p>To create a complete RDF/XML document, the serialization of the
    graph into XML is usually contained inside an <code>rdf:RDF</code>
    XML element which becomes the top-level XML document element.
    Conventionally the <code>rdf:RDF</code> element is also used to
    declare the XML namespaces that are used, although that is not
    required.  When there is only one top-level node element inside
    <code>rdf:RDF</code>, the <code>rdf:RDF</code> can be omitted
    although any XML namespaces must still be declared.</p>

    <p>The XML specification also permits an XML declaration at
    the top of the document with the XML version and possibly the XML
    content encoding.  This is optional but recommended.</p>

    <p>Completing the RDF/XML could be done for any of the correct
    complete graph examples from
    <a href="#example4">Example 4</a> onwards but taking the smallest
    <a href="#example6">Example 6</a> and adding the final components,
    gives a complete RDF/XML representation of the original
    <a href="#figure1">Figure 1</a> graph
    in <a href="#example7">Example 7</a>:</p>

    <aside class="example" id="example7"
         title="Complete RDF/XML description of Figure 1">

      <p>Description of <a href="#figure1">Figure 1</a> graph
        (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example07.rdf">example07.rdf</a>,
        output
        <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example07.nt">example07.nt</a>).</p>
      <pre class="rdf" data-transform="updateExample">
       <!--
       <?xml version="1.0"?>
       <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                   xmlns:dc="http://purl.org/dc/elements/1.1/"
                   xmlns:ex="http://example.org/stuff/1.0/">

         <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar"
                    dc:title="RDF 1.2 XML Syntax">
           <ex:editor>
             <rdf:Description ex:fullName="Dave Beckett">
               <ex:homePage rdf:resource="http://purl.org/net/dajobe/" />
             </rdf:Description>
           </ex:editor>
         </rdf:Description>

       </rdf:RDF>
       -->
      </pre>
    </aside>

    <p>It is possible to omit <code>rdf:RDF</code> in
    <a href="#example7">Example 7</a> above since there is only one
    <code>rdf:Description</code> inside <code>rdf:RDF</code> but this
    is not shown here.</p>
  </section>

  <!-- language attribute -->
  <section id="section-Syntax-languages">
    <h3>Languages: <code>xml:lang</code></h3>

    <p>RDF/XML permits the use of the <code>xml:lang</code> attribute as defined by
    <a data-cite="XML10#sec-lang-tag">2.12 Language Identification</a>
    of XML 1.0 [[XML10]]
    to allow the identification of content language.
    The <code>xml:lang</code> attribute can be used on any node element or property element
    to indicate that the included content is in the given language.
    <a href="#section-Syntax-datatyped-literals">Typed literals</a>
    which includes <a href="#section-Syntax-XML-literals">XML literals</a>
    are not affected by this attribute.
    The most specific in-scope language present
    (if any) is applied to property element string literal content or
    property attribute values.  The <code>xml:lang=""</code> form
    indicates the absence of a language identifier.</p>

    <p>Some examples of marking content languages for RDF properties are shown in
    <a href="#example8">Example 8</a>:</p>

    <aside class="example" id="example8"
         title="Complete example of xml:lang">
      <p><strong>Complete example of <code>xml:lang</code>
        (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example08.rdf">example08.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example08.nt">example08.nt</a>)</strong></p>

      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0" encoding="utf-8"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                 xmlns:dc="http://purl.org/dc/elements/1.1/">

          <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
            <dc:title>RDF 1.2 XML Syntax</dc:title>
            <dc:title xml:lang="en">RDF 1.2 XML Syntax</dc:title>
            <dc:title xml:lang="en-US">RDF 1.2 XML Syntax</dc:title>
          </rdf:Description>

          <rdf:Description rdf:about="http://example.org/buecher/baum" xml:lang="de">
            <dc:title>Der Baum</dc:title>
            <dc:description>Das Buch ist außergewöhnlich</dc:description>
            <dc:title xml:lang="en">The Tree</dc:title>
          </rdf:Description>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

  <!-- XML Literal -->
  <section id="section-Syntax-XML-literals" class="informative">
    <h3>XML Literals: <code>rdf:parseType="Literal"</code></h3>

    <p>RDF allows XML literals [RDF12-CONCEPTS]
    to be given as the object node of a predicate.
    These are written in RDF/XML as content of a property element (not
    a property attribute) and indicated using the
    <code>rdf:parseType="Literal"</code> attribute on the containing
    property element.
    </p>

    <p>An example of writing an XML literal is given in
    <a href="#example9">Example 9</a> where
    there is a single RDF triple with the subject node
    IRI
    <code>http://example.org/item01</code>, the predicate
    IRI
    <code>http://example.org/stuff/1.0/prop</code> (from
    <code>ex:prop</code>) and the object node with XML literal
    content beginning <code>a:Box</code>.
    </p>

    <aside class="example" id="example9" title="Complete example of rdf:parseType=Literal">
    <strong>Complete example of <code>rdf:parseType="Literal"</code>
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example09.rdf">example09.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example09.nt">example09.nt</a>)</strong>
      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                 xmlns:ex="http://example.org/stuff/1.0/">

          <rdf:Description rdf:about="http://example.org/item01">
            <ex:prop rdf:parseType="Literal" xmlns:a="http://example.org/a#">
              <a:Box required="true">
                <a:widget size="10" />
                <a:grommit id="23" />
              </a:Box>
            </ex:prop>
          </rdf:Description>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

  <!-- datatyped literals -->
  <section id="section-Syntax-datatyped-literals">
    <h3>Typed Literals: <code>rdf:datatype</code></h3>

    <p>RDF allows typed literals
    to be given as the object node of a predicate.  Typed literals consist of a literal
    string and a datatype
    IRI.  These are written in RDF/XML using
    the same syntax for literal string nodes in the property element form
    (not property attribute) but with an additional
    <code>rdf:datatype="</code><em>datatypeURI</em><code>"</code>
    attribute on the property element.  Any
    IRI can be used in the attribute.
    </p>

    <p>An example of an RDF typed
    literal
    is given in <a href="#example10">Example 10</a> where
    there is a single RDF triple with the subject node
    IRI
    <code>http://example.org/item01</code>, the predicate
    IRI
    <code>http://example.org/stuff/1.0/size</code> (from
    <code>ex:size</code>) and the object node with the
    typed literal
    ("123", <code>http://www.w3.org/2001/XMLSchema#int</code>)
    to be interpreted as an
    XML Schema [[XMLSCHEMA-2]] datatype <code>int</code>.
    </p>

    <aside class="example" id="example10" title="Complete example of rdf:datatype">
      <strong>Complete example of <code>rdf:datatype</code>
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example10.rdf">example10.rdf</a>,  output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example10.nt">example10.nt</a>)</strong>
      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                    xmlns:ex="http://example.org/stuff/1.0/">

          <rdf:Description rdf:about="http://example.org/item01">
            <ex:size rdf:datatype="http://www.w3.org/2001/XMLSchema#int">123</ex:size>
          </rdf:Description>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

  <!-- blank nodes -->
  <section id="section-Syntax-blank-nodes">
    <h3>Identifying Blank Nodes: <code>rdf:nodeID</code></h3>

    <p>Blank nodes in the RDF graph are distinct but have no
    IRI identifier.
    It is sometimes required that the same graph blank node is referred to in the
    RDF/XML in multiple places, such as at the subject and object
    of several RDF triples.  In this case, a blank node identifier
    can be given to the blank node for identifying it
    in the document.  Blank node identifiers in RDF/XML are scoped to the
    containing XML Information Set
    <a data-cite="XML-INFOSET#infoitem.document">document information item</a>.
    A blank node identifier is used
    on a node element to replace
    <code>rdf:about="</code><em>IRI</em><code>"</code>
    or on a property element to replace
    <code>rdf:resource="</code><em>IRI</em><code>"</code>

    with <code>rdf:nodeID="</code><em>blank node identifier</em><code>"</code>
    in both cases.</p>

    <p>Taking <a href="#example7">Example 7</a> and explicitly giving
    a blank node identifier of <code>abc</code> to the blank node in it
    gives the result shown in <a href="#example11">Example 11</a>.
    The second <code>rdf:Description</code> property element is
    about the blank node.</p>

    <aside class="example" id="example11" title="Complete RDF/XML description of graph using rdf:nodeID">
      <strong>Complete RDF/XML description of graph using <code>rdf:nodeID</code> identifying the blank node
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example11.rdf">example11.rdf</a>,  output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example11.nt">example11.nt</a>)</strong>
      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                    xmlns:dc="http://purl.org/dc/elements/1.1/"
                    xmlns:ex="http://example.org/stuff/1.0/">

          <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar"
                     dc:title="RDF 1.2 XML Syntax">
            <ex:editor rdf:nodeID="abc"/>
          </rdf:Description>

          <rdf:Description rdf:nodeID="abc" ex:fullName="Dave Beckett">
            <ex:homePage rdf:resource="http://purl.org/net/dajobe/"/>
          </rdf:Description>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

  <!-- parsetype resource -->
  <section id="section-Syntax-parsetype-resource">
    <h3>Omitting Blank Nodes: <code>rdf:parseType="Resource"</code></h3>

    <p>Blank nodes (not IRI nodes) in RDF graphs can be written
    in a form that allows the
    <code>&lt;rdf:Description&gt;</code>
    <code>&lt;/rdf:Description&gt;</code> pair to be omitted.
    The omission is done by putting an
    <code>rdf:parseType="Resource"</code>
    attribute on the containing property element
    that turns the property element into a property-and-node element,
    which can itself have both property elements and property attributes.
    Property attributes and the <code>rdf:nodeID</code> attribute
    are not permitted on property-and-node elements.</p>

    <p>Taking the earlier <a href="#example7">Example 7</a>,
    the contents of the <code>ex:editor</code> property element
    could be alternatively done in this fashion to give
    the form shown in <a href="#example12">Example 12</a>:</p>

    <aside class="example" id="example12" title="Complete example using rdf:parseType=Resource">
    <strong>Complete example using <code>rdf:parseType="Resource"</code>
    (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example12.rdf">example12.rdf</a>, output: <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example12.nt">example12.nt</a>)</strong>
    <pre class="rdf" data-transform="updateExample">
      <!--
      <?xml version="1.0"?>
      <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                  xmlns:dc="http://purl.org/dc/elements/1.1/"
                  xmlns:ex="http://example.org/stuff/1.0/">
        <rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar"
                         dc:title="RDF 1.2 XML Syntax">
          <ex:editor rdf:parseType="Resource">
            <ex:fullName>Dave Beckett</ex:fullName>
            <ex:homePage rdf:resource="http://purl.org/net/dajobe/"/>
          </ex:editor>
        </rdf:Description>
      </rdf:RDF>
      -->
    </pre>
    </aside>

  </section>

  <!-- attributes on property elements -->
  <section id="section-Syntax-property-attributes-on-property-element">
    <h3>Omitting Nodes: Property Attributes on an empty Property Element</h3>

    <p>If all of the property elements on a blank node element have
    string literal values with the same in-scope <code>xml:lang</code>
    value (if present) and each of these property elements appears at
    most once and there is at most one <code>rdf:type</code> property
    element with a IRI object node, these can be abbreviated by
    moving them to be property attributes on the containing property
    element which is made an empty element.</p>

    <p>Taking the earlier <a href="#example5">Example 5</a>,
    the <code>ex:editor</code> property element contains a
    blank node element with two property elements

    <code>ex:fullname</code> and <code>ex:homePage</code>.
    <code>ex:homePage</code> is not suitable here since it
    does not have a string literal value, so it is being
    <em>ignored</em> for the purposes of this example.
    The abbreviated form removes the <code>ex:fullName</code> property element
    and adds a new property attribute <code>ex:fullName</code> with the
    string literal value of the deleted property element
    to the <code>ex:editor</code> property element.
    The blank node element becomes implicit in the now empty

    <code>ex:editor</code> property element.  The result is shown in
    <a href="#example13">Example 13</a>.</p>

    <aside class="example" id="example13" title="Complete example of property attributes on an empty property element">
    <strong>Complete example of property attributes on an empty property element
    (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example13.rdf">example13.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example13.nt">example13.nt</a>)</strong>
    <pre class="rdf">
      &lt;?xml version="1.0"?&gt;
      &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                  xmlns:dc="http://purl.org/dc/elements/1.1/"
                  xmlns:ex="http://example.org/stuff/1.0/"&gt;

        &lt;rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar"
                  dc:title="RDF 1.2 XML Syntax"&gt;
          &lt;ex:editor ex:fullName="Dave Beckett" /&gt;
                  &lt;!-- Note the ex:homePage property has been ignored for this example --&gt;
        &lt;/rdf:Description&gt;

      &lt;/rdf:RDF&gt;
    </pre>
    </aside>

  </section>

  <!-- typed nodes -->
  <section id="section-Syntax-typed-nodes">
    <h3>Typed Node Elements</h3>

    <p>It is common for RDF graphs to have <code>rdf:type</code> predicates
    from subject nodes.  These are conventionally called <em>typed
    nodes</em> in the graph, or <em>typed node elements</em> in the
    RDF/XML.  RDF/XML allows this triple to be expressed more concisely.
    by replacing the <code>rdf:Description</code> node element name with
    the namespaced-element corresponding to the

    IRI of the value of
    the type relationship.  There may, of course, be multiple <code>rdf:type</code>
    predicates but only one can be used in this way, the others must remain as
    property elements or property attributes.
    </p>

    <p>The typed node elements are commonly used in RDF/XML with the built-in
    classes in the <a>RDF vocabulary</a>:
    <code>rdf:Seq</code>, <code>rdf:Bag</code>, <code>rdf:Alt</code>,

    <code>rdf:Statement</code>, <code>rdf:Property</code> and
    <code>rdf:List</code>.</p>

    <p>For example, the RDF/XML in <a href="#example14">Example 14</a>
    could be written as shown in <a href="#example15">Example 15</a>.</p>

    <aside class="example" id="example14">
      <strong>Complete example with <code>rdf:type</code>
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example14.rdf">example14.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example14.nt">example14.nt</a>)</strong>
      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                    xmlns:dc="http://purl.org/dc/elements/1.1/"
                    xmlns:ex="http://example.org/stuff/1.0/">

          <rdf:Description rdf:about="http://example.org/thing">
            <rdf:type rdf:resource="http://example.org/stuff/1.0/Document"/>
            <dc:title>A marvelous thing</dc:title>
          </rdf:Description>
        </rdf:RDF>
        -->
      </pre>

    </aside>

    <aside class="example" id="example15">
      <strong>Complete example using a typed node element to replace an <code>rdf:type</code>
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example15.rdf">example15.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example15.nt">example15.nt</a>)</strong>
      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                    xmlns:dc="http://purl.org/dc/elements/1.1/"
                    xmlns:ex="http://example.org/stuff/1.0/">

          <ex:Document rdf:about="http://example.org/thing">
            <dc:title>A marvelous thing</dc:title>
          </ex:Document>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

  <!-- xml base -->
  <section id="section-Syntax-ID-xml-base">
    <h3>Abbreviating URIs: <code>rdf:ID</code> and <code>xml:base</code></h3>

    <p>RDF/XML allows further abbreviating IRIs in XML attributes in two
    ways.  The XML Infoset provides a base URI attribute <code>xml:base</code>
    that sets the base URI for resolving relative IRIs, otherwise
    the base URI is that of the document.  The base URI applies to
    all RDF/XML attributes that deal with IRIs which are <code>rdf:about</code>,
    <code>rdf:resource</code>, <code>rdf:ID</code>
    and <code>rdf:datatype</code>.</p>

    <p>The <code>rdf:ID</code> attribute on a node element (not property
    element, that has another meaning) can be used instead of
    <code>rdf:about</code> and gives a relative IRI equivalent to <code>#</code>
    concatenated with the <code>rdf:ID</code> attribute value.  So for
    example if <code>rdf:ID="name"</code>, that would be equivalent
    to <code>rdf:about="#name"</code>.  <code>rdf:ID</code> provides an additional
    check since the same <em>name</em> can only appear once in the
    scope of an <code>xml:base</code> value (or document, if none is given),
    so is useful for defining a set of distinct,
    related terms relative to the same IRI.</p>

    <p>Both forms require a base URI to be known, either from an in-scope
    <code>xml:base</code> or from the URI of the RDF/XML document.</p>

    <p><a href="#example16">Example 16</a> shows abbreviating the node
    IRI of <code>http://example.org/here/#snack</code> using an
    <code>xml:base</code> of <code>http://example.org/here/</code> and
    an <code>rdf:ID</code> on the <code>rdf:Description</code> node element.
    The object node of the <code>ex:prop</code> predicate is an
    absolute IRI

    resolved from the <code>rdf:resource</code> XML attribute value
    using the in-scope base URI to give the
    IRI <code>http://example.org/here/fruit/apple</code>.</p>

    <aside class="example" id="example16" title="Complete example using rdf:ID> and xml:base">
      <strong>Complete example using <code>rdf:ID</code> and <code>xml:base</code> for shortening URIs
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example16.rdf">example16.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example16.nt">example16.nt</a>)</strong>
      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                    xmlns:ex="http://example.org/stuff/1.0/"
                    xml:base="http://example.org/here/">

          <rdf:Description rdf:ID="snack">
            <ex:prop rdf:resource="fruit/apple"/>
          </rdf:Description>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

  <!-- list elements -->
  <section id="section-Syntax-list-elements">
    <h3>Container Membership Property Elements: <code>rdf:li</code> and <code>rdf:_</code><em>n</em></h3>

    <p>RDF has a set of container membership properties
    and corresponding property elements that are mostly used with
    instances of the
    <code>rdf:Seq</code>, <code>rdf:Bag</code> and <code>rdf:Alt</code>
    classes which may be written as typed node elements.  The list properties are
    <code>rdf:_1</code>, <code>rdf:_2</code> etc. and can be written
    as property elements or property attributes as shown in
    <a href="#example17">Example 17</a>.  There is an <code>rdf:li</code>
    special property element that is equivalent to
    <code>rdf:_1</code>, <code>rdf:_2</code> in order,
    explained in detail in <a href="#section-List-Expand" class="sectionRef"></a>.
    The mapping to the container membership properties is
    always done in the order that the <code>rdf:li</code> special
    property elements appear in XML &mdash; the document order is significant.
    The equivalent RDF/XML to <a href="#example17">Example 17</a> written
    in this form is shown in <a href="#example18">Example 18</a>.
    </p>

    <aside class="example" id="example17" title="Complex example using RDF list properties">
    <strong>Complex example using RDF list properties
    (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example17.rdf">example17.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example17.nt">example17.nt</a>)</strong>

    <pre class="rdf" data-transform="updateExample">
      <!--
    <?xml version="1.0"?>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">

      <rdf:Seq rdf:about="http://example.org/favourite-fruit">
        <rdf:_1 rdf:resource="http://example.org/banana"/>
        <rdf:_2 rdf:resource="http://example.org/apple"/>
        <rdf:_3 rdf:resource="http://example.org/pear"/>
      </rdf:Seq>

    </rdf:RDF>
      -->
    </pre>
    </aside>

    <aside class="example" id="example18" title="Complete example using rdf:li">
    <strong>Complete example using <code>rdf:li</code> property element for list properties
    (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example18.rdf">example18.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example18.nt">example18.nt</a>)</strong>

    <pre class="rdf" data-transform="updateExample">
      <!--
      <?xml version="1.0"?>
      <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">

        <rdf:Seq rdf:about="http://example.org/favourite-fruit">
          <rdf:li rdf:resource="http://example.org/banana"/>
          <rdf:li rdf:resource="http://example.org/apple"/>
          <rdf:li rdf:resource="http://example.org/pear"/>
        </rdf:Seq>

      </rdf:RDF>
      -->
    </pre>
    </aside>

  </section>

  <!-- parsetype collection -->
  <section id="section-Syntax-parsetype-Collection">
    <h3>Collections: <code>rdf:parseType="Collection"</code></h3>

    <p>RDF/XML allows an <code>rdf:parseType="Collection"</code>

    attribute on a property element to let it contain multiple node
    elements.  These contained node elements give the set of subject
    nodes of the collection.  This syntax form corresponds to a set of
    triples connecting the collection of subject nodes, the exact triples
    generated are described in detail in
    <a href="#parseTypeCollectionPropertyElt" class="sectionRef"></a>.
    The collection construction is always done in the order that the node
    elements appear in the XML document.  Whether the order of the
    collection of nodes is significant is an application issue and not
    defined here.
    </p>

    <p><a href="#example19">Example 19</a> shows a collection of three
    nodes elements at the end of the <code>ex:hasFruit</code>
    property element using this form.</p>

    <aside class="example" id="example19" title="Complete example of a RDF collection">
      <strong>Complete example of a RDF collection of nodes using <code>rdf:parseType="Collection"</code>
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example19.rdf">example19.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example19.nt">example19.nt</a>)</strong>

      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                    xmlns:ex="http://example.org/stuff/1.0/">

          <rdf:Description rdf:about="http://example.org/basket">
            <ex:hasFruit rdf:parseType="Collection">
              <rdf:Description rdf:about="http://example.org/banana"/>
              <rdf:Description rdf:about="http://example.org/apple"/>
              <rdf:Description rdf:about="http://example.org/pear"/>
            </ex:hasFruit>
          </rdf:Description>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

  <!-- reification -->
  <section id="section-Syntax-reifying">
    <h3>Reifying Statements: <code>rdf:ID</code></h3>

    <p>The <code>rdf:ID</code> attribute can be used on a property
    element to reify the triple that it generates (See
    <a href="#section-Reification" class="sectionRef"></a> for the
    full details).
    The identifier for the triple should be constructed as a
    IRI
    made from the relative IRI
    <code>#</code> concatenated with the <code>rdf:ID</code> attribute
    value, resolved against the in-scope base URI.  So for example if

    <code>rdf:ID="triple"</code>, that would be equivalent to the IRI
    formed from relative IRI <code>#triple</code> against the base URI.
    Each (<code>rdf:ID</code> attribute value, base URI)
    pair has to be unique in an RDF/XML document,
    see <a>constraint-id</a>.
    </p>

    <p><a href="#example20">Example 20</a> shows a <code>rdf:ID</code>
    being used to reify a triple made from the <code>ex:prop</code>
    property element giving the reified triple the
    IRI <code>http://example.org/triples/#triple1</code>.</p>

    <aside class="example" id="example20">
      <strong>Complete example of <code>rdf:ID</code> reifying a property element
      (<a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example20.rdf">example20.rdf</a>, output <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/example20.nt">example20.nt</a>)</strong>

      <pre class="rdf" data-transform="updateExample">
        <!--
        <?xml version="1.0"?>
        <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                    xmlns:ex="http://example.org/stuff/1.0/"
                    xml:base="http://example.org/triples/">
          <rdf:Description rdf:about="http://example.org/">
            <ex:prop rdf:ID="triple1">blah</ex:prop>
          </rdf:Description>

        </rdf:RDF>
        -->
      </pre>
    </aside>

  </section>

</section>

<!-- SECOND PART : TERMINILOGY -->

<section id="conformance">
  <span id="section-conformance"><!-- old section id --></span>
  <p>All use of string without further qualification refers to
  a Unicode [[UNICODE]] character string;
  a sequence of characters represented by a code point in
  Unicode.</p>

  <dl>
  <dt>Definition:</dt>
    <dd>An <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-document">RDF Document</dfn> is a serialization of an
    <a data-cite="RDF12-CONCEPTS#dfn-rdf-graph">RDF Graph</a>
    into a concrete syntax.</dd>

  <dt>Definition:<br /></dt>
    <dd>An <dfn>RDF/XML Document</dfn> is an
    <a data-cite="RDF12-CONCEPTS#dfn-rdf-document">RDF Document</a> written in the
    XML syntax for RDF as defined in this document.</dd>

  <dt>Conformance:<br /></dt>
    <dd>An <a>RDF/XML Document</a> is a
    <dfn data-lt="conforming document" class="export">conforming RDF/XML document</dfn>
    if it adheres to the specification defined in this document.</dd>
  </dl>

  <section id="section-MIME-Type">
    <h2>RDF MIME Type, File Extension and Macintosh File Type</h2>

    <p>The Internet media type / MIME type for RDF/XML is
    <code>application/rdf+xml</code> &mdash; [[RFC3870]].
    </p>

    <p>It is recommended that RDF/XML files have the extension
    <code>".rdf"</code> (all lowercase) on all platforms.</p>

    <p>It is recommended that RDF/XML files stored on Macintosh HFS file
    systems be given a file type of <code>"rdf&nbsp;"</code>
    (all lowercase, with a space character as the fourth letter).</p>
  </section>

  <section class="informative" id="privacy-considerations">
    <h2>Privacy Considerations</h2>
    <p class="ednote">TODO</p>  
  </section>

  <section class="informative" id="security">
    <h2>Security Considerations</h2>

    <p>See the <a data-cite="RFC3870#section-6">Security Considerations Section</a>
      of [[RFC3870]].</p>
  </section>

</section>


<!-- FOURTH PART : Global Issues -->

<section id="section-Global">
    <h2>Global Issues</h2>

    <!-- namespace -->
    <section id="section-Namespace">

    <h3>The RDF Namespace and Vocabulary</h3>

     <p>The <dfn data-cite="RDF12-CONCEPTS#dfn-namespace-iri" id="rdf-ns-uri">RDF namespace IRI</dfn> (or namespace name) is
    <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code>
    and is typically used in XML with the prefix <code>rdf</code>
    although other prefix strings may be used.
    The <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-vocabulary">RDF Vocabulary</dfn>
    is identified by this namespace name and consists of the following names only:</p>

    <dl>
    <dt>Syntax names &mdash; not concepts</dt>
    <dd>
    <p>
    <code>RDF Description ID about parseType resource li nodeID datatype</code>
    </p>
    </dd>

    <dt>Class names</dt>
    <dd>
    <p>
    <code>Seq Bag Alt Statement Property XMLLiteral List</code>
    </p>
    </dd>

    <dt>Property names</dt>
    <dd>
    <p>
    <code>subject predicate object type value first rest _</code><em>n</em><br />
    where <em>n</em> is a decimal integer greater than zero with no leading zeros.
    </p>
    </dd>

    <dt>Resource names</dt>
    <dd>
    <p>
    <code>nil</code>
    </p>
    </dd>

    </dl>

    <p>Any other names are not defined and SHOULD generate a warning when
    encountered, but should otherwise behave normally.</p>

    <p>Within RDF/XML documents it is not permitted to use XML namespaces
    whose namespace name is the
    <a href="#rdf-ns-uri" class="termref"><span class="arrow">·</span>RDF namespace IRI<span class="arrow">·</span></a>

    concatenated with additional characters.</p>

    <p>Throughout this document the terminology <code>rdf:</code><em>name</em>
    will be used to indicate <em>name</em> is from the RDF vocabulary
    and it has a IRI of the concatenation of the
    <a href="#rdf-ns-uri" class="termref"><span class="arrow">·</span>RDF namespace IRI<span class="arrow">·</span></a> and <em>name</em>.
    For example, <code>rdf:type</code> has the IRI
    <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#type</code></p>
    </section>


    <!-- identifiers -->
    <section id="section-Identifiers">
    <h3>Identifiers</h3>

    <p>The RDF Concepts document [[RDF12-CONCEPTS]]
    defines the three types of RDF data that can act as node
    and/or predicate:</p>

    <dl>

    <dt>IRI</dt>
    <dd>
<p>IRIs can act as node (both subject and object) and as
    predicate. </p>

    <p><a data-cite="RDF12-CONCEPTS#dfn-iri">IRIs</a> can be either:</p>
    <ul>
    <li>given as XML attribute values interpreted as relative
    IRIs that are resolved against the in-scope base URI
    as described in <a href="#section-baseURIs" class="sectionRef"></a>
    to give absolute IRIs</li>
    <li>transformed from XML namespace-qualified element and attribute names
    (QNames)</li>
    <li>transformed from <code>rdf:ID</code> attribute values.</li>
    </ul>

    <p>Within RDF/XML, XML QNames are transformed into
    IRIs
    by appending the XML local name to the namespace name (IRI).
    For example, if the XML namespace prefix <code>foo</code> has
    namespace name (IRI)

    <code>http://example.org/somewhere/</code> then the QName
    <code>foo:bar</code> would correspond to the IRI
    <code>http://example.org/somewhere/bar</code>.  Note that this
    restricts which
    IRIs can be made and the same IRI can be given in multiple ways.</p>

    <p>The <a href="#idAttr"><code>rdf:ID</code></a> values
    are transformed into
    IRIs
    by appending the attribute value to the result of appending
    "#" to the in-scope base URI which is defined in
    <a href="#section-baseURIs" class="sectionRef"></a></p>
    </dd>

    <dt>Literal</dt>
    <dd>
<p>Literals can only act as object nodes.</p>

    <p><a data-cite="RDF12-CONCEPTS#dfn-literal">Literals</a> always have a datatype. Language-tagged strings get
    the datatype <code>rdf:langString</code>. When there is no
    language tag or datatype specified the literal is assumed to have the datatype
    <code>xsd:string</code>. </p>
    </dd>

    <dt>Blank Node</dt>
    <dd>
    <p>Blank nodes can act as subject node and as object node.</p>
    <p><a data-cite="RDF12-CONCEPTS#dfn-blank-node">Blank nodes</a> have distinct identity in the RDF graph.
    When the graph is written in a syntax such as RDF/XML, these
    blank nodes may need graph-local identifiers and a syntax
    in order to preserve this distinction.  These local identifiers are called
    blank node identifiers
    and are used in RDF/XML as values of the <code>rdf:nodeID</code> attribute
    with the syntax given in <a href="#nodeIdAttr">Production nodeIdAttr</a>.
    Blank node identifiers in RDF/XML are scoped to the XML Information Set
    <a data-cite="XML-INFOSET#infoitem.document">document information item</a>.</p>

    <p>If no blank node identifier is given explicitly as an
    <code>rdf:nodeID</code> attribute value then one will need to be
    generated (using generated-blank-node-id,
    see <a href="#section-Infoset-Grammar-Action" class="sectionRef"></a>).
    Such generated blank node
    identifiers must not clash with any blank node identifiers derived
    from <code>rdf:nodeID</code> attribute values.  This can be
    implemented by any method that preserves the distinct identity of all
    the blank nodes in the graph, that is, the same blank node identifier
    is not given for different blank nodes.  One possible method would be
    to add a constant prefix to all the <code>rdf:nodeID</code> attribute
    values and ensure no generated blank node identifiers ever used that
    prefix.  Another would be to map all <code>rdf:nodeID</code> attribute
    values to new generated blank node identifiers and perform that mapping
    on all such values in the RDF/XML document.</p>
    </dd>
    </dl>

    </section>


    <!-- uri resolution -->
    <section id="section-baseURIs">
    <h3>Resolving IRIs</h3>

    <p>RDF/XML supports
    XML Base [[XMLBASE]]
    which defines a
    <a href="#eventterm-element-base-uri" class="termref"><span
    class="arrow">·</span>base-uri<span class="arrow">·</span></a>
    accessor for each <a href="#section-root-node"><span
    class="arrow">·</span>root event<span
    class="arrow">·</span></a> and
    <a href="#section-element-node"><span
    class="arrow">·</span>element event<span
    class="arrow">·</span></a>.
    Relative IRIs are resolved into
    IRIs
    according to the algorithm specified in [[XMLBASE]] (and RFC 2396).
    These specifications do not specify an algorithm for resolving a
    fragment identifier alone, such as <code>#foo</code>, or the empty
    string <code>""</code> into an
    IRI. In RDF/XML, a fragment identifier
    is transformed into an IRI
    by appending the fragment identifier to the in-scope base URI. The
    empty string is transformed
    into an IRI by substituting the in-scope base URI.
    </p>

    <p class="note"><strong>Test:</strong>
    indicated by: <br/>
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test001.rdf">test001.rdf</a> and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test001.nt">test001.nt</a>
    <br/>
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test004.rdf">test004.rdf</a> and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test004.nt">test004.nt</a>
    <br/>
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test008.rdf">test008.rdf</a> and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test008.nt">test008.nt</a>
    </p>

    <p>An empty same document reference ""
    resolves against the URI part of the base URI; any fragment part
    is ignored.  See
    Uniform Resource Identifiers (URI) [[RFC3986]].
    </p>

    <p class="note"><strong>Test:</strong>
    Indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test013.rdf">test013.rdf</a> and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test013.nt">test013.nt</a>
    </p>

    <p class="note"><strong>Implementation Note (Informative):</strong>
    When using a hierarchical base
    URI that has no path component (/), it must be added before using as a
    base URI for resolving.
    </p>

    <p class="note"><strong>Test:</strong>
    Indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test011.rdf">test011.rdf</a> and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test011.nt">test011.nt</a>
    </p>
    </section>


    <!-- constraints -->
    <section id="section-constraints">
    <h3>Constraints</h3>

    <dl>
    <dt><dfn>constraint-id</dfn></dt>
    <dd><p>Each application of production <a href="#idAttr">idAttr</a>
    matches an attribute.  The pair formed by the
    <a href="#eventterm-attribute-string-value" class="termref"><span class="arrow">·</span>string-value<span class="arrow">·</span></a>
    accessor of the matched attribute and the
    <a href="#eventterm-element-base-uri" class="termref"><span class="arrow">·</span>base-uri<span class="arrow">·</span></a>
    accessor of the matched attribute is unique within a single RDF/XML
    document.</p>

    <p>The syntax of the  names must match the
    <a href="#rdf-id">rdf-id production</a>.</p>

    <p class="note"><strong>Test:</strong>
    Indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test014.rdf">test014.rdf</a> and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/xmlbase/test014.nt">test014.nt</a>
    </p>
    </dd>

    </dl>
    </section>

</section>


<!-- FIFTH PART : Data Model -->

<section id="section-Data-Model">

  <h2>Syntax Data Model</h2>

  <p>This document specifies the syntax of RDF/XML as a grammar on an
    alphabet of symbols. The symbols are called <em>events</em> in the
    style of the XPATH &#160;
    <a data-cite="XPATH#infoset">Information Set Mapping</a>.
    A sequence of events is normally derived from an XML document, in
    which case they are in document order as defined below in
    <a href="#section-Infoset-Mapping" class="sectionRef"></a>.
    The sequence these events form are intended to be similar to the sequence
    of events produced by the [[SAX]] XML API from
    the same XML document.  Sequences of events may be checked against
    the grammar to determine whether they are or are not syntactically
    well-formed RDF/XML.</p>

  <p>The grammar productions may include actions which fire when the
    production is recognized.  Taken together these actions define a
    transformation from any syntactically well-formed RDF/XML sequence of
    events into an RDF graph represented in the N-Triples [[RDF12-N-TRIPLES]]
    language.</p>

  <p>The model given here illustrates one way to create a representation of
    an RDF Graph
    from an RDF/XML document.  It does not mandate any implementation
    method &mdash; any other method that results in a representation of the same
    RDF Graph may be used.</p>

  <p>In particular:</p>
  <ul>
    <li>This specification permits any
      representation of an RDF graph;
      in particular, it does not require the use of N-Triples [[RDF12-N-TRIPLES]].</li>
    <li>This specification does not require the use of
      [[XPATH]] or [[SAX]]</li>
    <li>This specification places no constraints on the order in which
      software transforming RDF/XML into a representation of a graph,
      constructs the representation of the graph.</li>
    <li>Software transforming RDF/XML into a representation of a graph
      MAY eliminate duplicate predicate arcs.</li>
  </ul>

  <p>The syntax does not support non-well-formed XML documents, nor
    documents that otherwise do not have an XML Information Set; for
    example, that do not conform to
    Namespaces in XML [[XML-NAMES]].</p>

  <p>The Infoset requires support for
    XML Base [[XMLBASE]].
    RDF/XML uses the information item property [base URI], discussed in
    <a href="#section-baseURIs" class="sectionRef"></a></p>

  <p>This specification requires an
    XML Information Set [[XML-INFOSET]]
    which supports at least the following information items and
    properties for RDF/XML:</p>

  <dl>
    <dt><a data-cite="XML-INFOSET#infoitem.document">document information item</a></dt>
    <dd>[document element], [children], [base URI]</dd>

    <dt><a data-cite="XML-INFOSET#infoitem.element">element information item</a></dt>
    <dd>[local name], [namespace name], [children], [attributes], [parent], [base URI]</dd>

    <dt><a data-cite="XML-INFOSET#infoitem.attribute">attribute information item</a></dt>
    <dd>[local name], [namespace name], [normalized value]</dd>

    <dt><a data-cite="XML-INFOSET#infoitem.character">character information item</a></dt>
    <dd>[character code]</dd>
  </dl>

  <p>There is no mapping of the following items to data model events:</p>
  <ul>
    <li><a data-cite="XML-INFOSET#infoitem.pi">processing instruction information item</a></li>
    <li><a data-cite="XML-INFOSET#infoitem.rse">unexpanded entity reference information item</a></li>
    <li><a data-cite="XML-INFOSET#infoitem.comment">comment information item</a></li>
    <li><a data-cite="XML-INFOSET#infoitem.doctype">document type declaration information item</a></li>

    <li><a data-cite="XML-INFOSET#infoitem.entity.unparsed">unparsed entity information item</a></li>
    <li><a data-cite="XML-INFOSET#infoitem.notation">notation information item</a></li>
    <li><a data-cite="XML-INFOSET#infoitem.namespace">namespace information item</a></li>
  </ul>

  <p>Other information items and properties have no mapping to
    syntax data model events.</p>

  <p>Element information items with reserved XML Names
    (See <a data-cite="XML10#dt-name">Name</a> in [[[XML10]]])
    are not mapped to data model element events.
    These are all those with property [prefix] beginning with <code>xml</code>
    (case independent comparison) and all those with [prefix] property
    having no value and which have [local name] beginning with
    <code>xml</code> (case independent comparison).</p>

  <p>All information items contained inside XML elements matching the
    <a href="#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a>
    production form XML literals and do not follow this mapping.
    See <a href="#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a>
    for further information.</p>

  <p>This section is intended to satisfy the requirements for
    <a data-cite="XML-INFOSET#conformance">Conformance</a>
    in the [[XML-INFOSET]] specification.
    It specifies the information items and properties that are needed
    to implement this specification.</p>

  <!-- events -->
  <section id="section-Nodes">
    <h3>Events</h3>

    <p>There are nine types of event defined in the following subsections.
      Most events are constructed from an Infoset information item (except
      for <a href="#section-identifier-node">IRI</a>,
      <a href="#section-blank-nodeid-event">blank node</a>,
      <a href="#section-literal-node">plain literal</a> and
      <a href="#section-typed-literal-node">typed literal</a>).  The effect
      of an event constructor is to create a new event with a unique identity,
      distinct from all other events.  Events have accessor operations on them
      and most have the <em>string-value</em> accessor that may be a static value
      or computed.</p>

    <!-- root event -->
    <section id="section-root-node">
      <h3>Root Event</h3>

      <p>Constructed from a
        <a data-cite="XML-INFOSET#infoitem.document">document information item</a>
        and takes the following accessors and values.</p>

      <dl>
      <dt id="eventterm-root-document-element">document-element</dt>
      <dd>Set to the value of document information item property [document-element].</dd>
      <dt id="eventterm-root-children">children</dt>
      <dd>Set to the value of document information item property [children].</dd>
      <dt id="eventterm-root-base-uri">base-uri</dt>
      <dd>Set to the value of document information item property [base URI].</dd>
      <dt id="eventterm-root-language">language</dt>
      <dd>Set to the empty string.</dd>
      </dl>
    </section>

    <!-- root event -->
    <section id="section-element-node">
      <h3>Element Event</h3>

      <p>Constructed from an
      <a data-cite="XML-INFOSET#infoitem.element">element information item</a>
      and takes the following accessors and values:</p>

      <dl>
        <dt id="eventterm-element-local-name">local-name</dt>
        <dd>Set to the value of element information item property [local name].</dd>

        <dt id="eventterm-element-namespace-name">namespace-name</dt>
        <dd>Set to the value of element information item property [namespace name].</dd>

        <dt id="eventterm-element-children">children</dt>
        <dd>Set to the value of element information item property [children].</dd>

        <dt id="eventterm-element-parent">parent</dt>
        <dd>Set to the value of element information item property [parent].</dd>

        <dt id="eventterm-element-base-uri">base-uri</dt>
        <dd>Set to the value of element information item property [base URI].</dd>

        <dt id="eventterm-element-attributes">attributes</dt>
        <dd>
          <p>Made from the value of element information item
            property [attributes] which is a set of attribute
            information items.</p>

          <p>If this set contains an attribute information item
            <code>xml:lang</code> ([namespace name] property with the value
            "http://www.w3.org/XML/1998/namespace" and
            [local name] property value "lang")
            it is removed from the set of attribute information items and the
            <a href="#eventterm-element-language" class="termref">
              <span class="arrow">·</span>language<span class="arrow">·</span></a>
              accessor is set to the [normalized-value] property of the
              attribute information item.</p>

          <p>All remaining reserved XML Names
            (see <a data-cite="XML10#dt-name">Name</a> in [[[XML10]]])
            are now removed from the set.
            These are, all attribute information items in the set with property [prefix]
            beginning with <code>xml</code>
            (case independent comparison) and all attribute information items with [prefix]
            property having no value and which have [local name] beginning with
            <code>xml</code> (case independent comparison) are removed.
            Note that the [base URI] accessor is computed by XML Base before any
            <code>xml:base</code> attribute information item is deleted.</p>

          <p>The remaining set of attribute information items are then used
            to construct a new set of
            <a href="#section-attribute-node">Attribute Events</a>
            which is assigned as the value of this accessor.</p>
        </dd>

        <dt id="eventterm-element-URI">URI</dt>
        <dd>Set to the string value of the concatenation of the
          value of the namespace-name accessor and the value of the
          local-name accessor.</dd>

        <dt id="eventterm-element-URI-string-value">URI-string-value</dt>
        <dd>
          <p>The value is the concatenation of the following in this order "&lt;",
          the escaped value of the
          <a href="#eventterm-element-URI" class="termref">
            <span class="arrow">·</span>URI<span class="arrow">·</span>
          </a>
          accessor and "&gt;".</p>

          <p>The escaping of the
            <a href="#eventterm-element-URI" class="termref">
              <span class="arrow">·</span>URI<span class="arrow">·</span>
            </a>
            accessor uses the N-Triples escapes for
            IRIs [[RDF12-N-TRIPLES]].</p>

        </dd>

        <dt id="eventterm-element-liCounter">li-counter</dt>
        <dd>Set to the integer value 1.</dd>

        <dt id="eventterm-element-language">language</dt>
        <dd>Set from the
          <a href="#eventterm-element-attributes"
          class="termref"><span class="arrow">·</span>attributes<span
          class="arrow">·</span></a>
          as described above.
          If no value is given from the attributes, the value is set to the value of
          the language accessor on the parent event (either a
          <a href="#section-root-node">Root Event</a> or an
          <a href="#section-element-node">Element Event</a>), which may be the empty string.
        </dd>

        <dt id="eventterm-element-subject">subject</dt>
        <dd>Has no initial value.  Takes a value that is an
          <a href="#section-identifier-node">Identifier</a> event.
          This accessor is used on elements that deal with one node in the RDF graph,
          this generally being the subject of a statement.
        </dd>

      </dl>
    </section>
    <!-- end element event -->

    <section id="section-end-element-node">
      <h3>End Element Event</h3>

      <p>Has no accessors.  Marks the end of the containing element in
        the sequence.</p>
    </section>

    <!-- attribute event -->
    <section id="section-attribute-node">
      <h3>Attribute Event</h3>

      <p>Constructed from an
        <a data-cite="XML-INFOSET#infoitem.attribute">attribute information item</a>
        and takes the following accessors and values:</p>

      <dl>
        <dt id="eventterm-attribute-local-name">local-name</dt>
        <dd>Set to the value of attribute information item property [local name].</dd>

        <dt id="eventterm-attribute-namespace-name">namespace-name</dt>
        <dd>Set to the value of attribute information item property [namespace name].</dd>

        <dt id="eventterm-attribute-string-value">string-value</dt>
        <dd>Set to the value of the attribute information item
          property [normalized value] as specified by [[XML10]] (if an attribute whose normalized
          value is a zero-length string, then the string-value is also
          a zero-length string).
        </dd>

        <dt id="eventterm-attribute-URI">URI</dt>
        <dd>
          <p>If <a href="#eventterm-attribute-namespace-name"
            class="termref"><span
            class="arrow">·</span>namespace-name<span
            class="arrow">·</span></a> is present,
            set to a string value of the concatenation of the value of the
            <a href="#eventterm-attribute-namespace-name"
            class="termref"><span
            class="arrow">·</span>namespace-name<span
            class="arrow">·</span></a> accessor
            and the value of the
            <a href="#eventterm-attribute-local-name"
            class="termref"><span class="arrow">·</span>local-name<span
            class="arrow">·</span></a> accessor.
            Otherwise if <a href="#eventterm-attribute-local-name"
            class="termref"><span class="arrow">·</span>local-name<span
            class="arrow">·</span></a> is
            <code>ID</code>, <code>about</code>, <code>resource</code>,
            <code>parseType</code> or <code>type</code>, set to a string
            value of the concatenation of the
            <a href="#rdf-ns-uri" class="termref"><span
            class="arrow">·</span>RDF namespace IRI<span
            class="arrow">·</span></a>
            and the value of the <a
            href="#eventterm-attribute-local-name" class="termref"><span
            class="arrow">·</span>local-name<span
            class="arrow">·</span></a> accessor.   Other non-namespaced
            <a href="#eventterm-attribute-local-name"
            class="termref"><span class="arrow">·</span>local-name<span
            class="arrow">·</span></a> accessor values are
            forbidden.</p>

          <p>The support for a limited set of non-namespaced names is
            REQUIRED and intended to allow RDF/XML documents specified in
            [[RDF-SYNTAX-GRAMMAR-19990222]] to remain valid; new documents
            SHOULD NOT use these unqualified attributes and applications MAY
            choose to warn when the unqualified form is seen in a document.</p>

          <p>The construction of IRIs from XML attributes can generate the same
            IRIs from different XML attributes.  This can cause ambiguity in the
            grammar when matching attribute events (such as when
            <code>rdf:about</code> and <code>about</code> XML attributes are
            both present).  Documents that have this are illegal.
          </p>
        </dd>

        <dt id="eventterm-attribute-URI-string-value">URI-string-value</dt>
        <dd>
          <p>The value is the concatenation of the following in this order "&lt;",
            the escaped value of the
            <a href="#eventterm-attribute-URI" class="termref"><span
              class="arrow">·</span>URI<span class="arrow">·</span></a>
            accessor and "&gt;".</p>

          <p>The escaping of the
            <a href="#eventterm-attribute-URI" class="termref"><span
            class="arrow">·</span>URI<span class="arrow">·</span></a>
            accessor uses the N-Triples escapes for
            IRIs [[RDF12-N-TRIPLES]].
          </p>
        </dd>

      </dl>
    </section>


    <!-- text event -->
    <section id="section-text-node">
      <h3>Text Event</h3>

      <p>Constructed from a sequence of one or more consecutive
        <a data-cite="XML-INFOSET#infoitem.character">character information items</a>.
        Has the single accessor:</p>

      <dl>
        <dt id="eventterm-text-string-value">string-value</dt>
        <dd>Set to the value of the string made from concatenating the
          [<a data-cite="XML-INFOSET#infoitem.character">character code</a>]
          property of each of the character information items.
        </dd>
      </dl>
    </section>


    <!-- uri reference event -->
    <section id="section-identifier-node">
      <h3>IRI Event</h3>

      <p id="eventterm-identifier-identifier-type">
        An event for a IRIs which has the following accessors:</p>

      <dl>
        <dt id="eventterm-identifier-identifier">identifier</dt>
        <dd>Takes a string value used as an IRI.</dd>

        <dt id="eventterm-identifier-string-value">string-value</dt>
        <dd>
          <p>The value is the concatenation of "&lt;", the escaped
            value of the <a href="#eventterm-identifier-identifier"
            class="termref"><span class="arrow">·</span>identifier<span
            class="arrow">·</span></a> accessor and "&gt;"</p>

          <p>The escaping of the <a
            href="#eventterm-identifier-identifier"
            class="termref"><span
            class="arrow">·</span>identifier<span
            class="arrow">·</span></a> accessor value
            uses the N-Triples escapes for IRIs [[RDF12-N-TRIPLES]]. </p>

        </dd>

      </dl>

      <p>These events are constructed by giving a value for the
        <a href="#eventterm-identifier-identifier"
        class="termref"><span class="arrow">·</span>identifier<span
        class="arrow">·</span></a> accessor.
      </p>

      <p>For further information on identifiers in the RDF graph, see
        <a href="#section-Identifiers" class="sectionRef"></a>.</p>
    </section>


    <!-- blank node identifier event -->
    <section id="section-blank-nodeid-event">
      <h3>Blank Node Identifier Event</h3>

      <p>An event for a blank node identifier
        which has the following accessors:</p>

      <dl>
        <dt id="eventterm-blanknodeid-identifier">identifier</dt>
        <dd>Takes a string value.</dd>

        <dt id="eventterm-blanknodeid-string-value">string-value</dt>
        <dd>The value is a function of the value of the
          <a href="#eventterm-blanknodeid-identifier"
          class="termref"><span class="arrow">·</span>identifier<span
          class="arrow">·</span></a> accessor.
          The value begins with "_:" and the entire value MUST match the
          N-Triples
          <a data-cite="RDF12-N-TRIPLES#grammar-production-BLANK_NODE_LABEL">BLANK_NODE_LABELD</a> production.
          The function MUST preserve distinct blank node identity as
          discussed in in section <a href="#section-Identifiers" class="sectionRef"></a>.
        </dd>

      </dl>

      <p>These events are constructed by giving a value for the
        <a href="#eventterm-blanknodeid-identifier"
        class="termref"><span class="arrow">·</span>identifier<span
        class="arrow">·</span></a> accessor.
      </p>

      <p>For further information on identifiers in the RDF graph, see
        <a href="#section-Identifiers" class="sectionRef"></a>.</p>
    </section>


    <!-- plain literal event -->
    <section id="section-literal-node">
      <h3>Plain Literal Event</h3>

      <p class="note">RDF/XML plain literals are in RDF 1.2 treated as
        syntactic sugar for a literal with datatype
        <code>xsd:string</code> (in case no language tag is present)
        or as a literal with datatype <code>rdf:langString</code> (in
        case a language tag is present). The mapping to N-Triples as
        defined in this subsection is not affected by this change. </p>

      <p>An event for a plain literal which can have the following accessors:</p>

      <dl>
        <dt id="eventterm-literal-literal-value">literal-value</dt>
        <dd>Takes a string value.</dd>

        <dt id="eventterm-literal-literal-language">literal-language</dt>
        <dd>Takes a string value used as a language tag in an RDF plain literal.</dd>

        <dt id="eventterm-literal-string-value">string-value</dt>
        <dd>
          <p>The value is calculated from the other accessors as follows.</p>

          <p>If <a href="#eventterm-literal-literal-language"
            class="termref"><span
            class="arrow">·</span>literal-language<span
            class="arrow">·</span></a> is the empty string
            then the value is the concatenation of "&quot;" (1 double quote),
            the escaped value of the
            <a href="#eventterm-literal-literal-value"
            class="termref"><span
            class="arrow">·</span>literal-value<span
            class="arrow">·</span></a> accessor
            and "&quot;" (1 double quote).</p>

          <p>Otherwise the value is the concatenation of "&quot;" (1 double quote),
            the escaped value of the
            <a href="#eventterm-literal-literal-value"
            class="termref"><span
            class="arrow">·</span>literal-value<span
            class="arrow">·</span></a> accessor
           "&quot;@" (1 double quote and a '@'),
            and the value of the
            <a href="#eventterm-literal-literal-language"
            class="termref"><span
            class="arrow">·</span>literal-language<span
            class="arrow">·</span></a> accessor.</p>

          <p>The escaping of the <a
            href="#eventterm-literal-literal-value" class="termref"><span
            class="arrow">·</span>literal-value<span
            class="arrow">·</span></a> accessor value uses the N-Triples
            escapes for strings as described in [[RDF12-N-TRIPLES]]
            for escaping certain characters such as &quot;. </p>
        </dd>
      </dl>

      <p>These events are constructed by giving values for the
        <a href="#eventterm-literal-literal-value"
        class="termref"><span class="arrow">·</span>literal-value<span
        class="arrow">·</span></a> and
        <a href="#eventterm-literal-literal-language"
        class="termref"><span
        class="arrow">·</span>literal-language<span
        class="arrow">·</span></a> accessors.</p>

      <p class="note" id="literal-comb-char-note1">
        <strong>Interoperability Note (Informative):</strong>
        Literals beginning with a Unicode combining character are
        allowed however they may cause interoperability problems.
        See [[CHARMOD]] for further information.
      </p>
    </section>


    <!-- typed literal event -->
    <section id="section-typed-literal-node">
      <h3>Typed Literal Event</h3>

      <p>An event for a typed literal which can have the following accessors:</p>

      <dl>
        <dt id="eventterm-typedliteral-literal-value">literal-value</dt>
        <dd>Takes a string value.</dd>

        <dt id="eventterm-typedliteral-literal-datatype">literal-datatype</dt>
        <dd>Takes a string value used as an IRI.</dd>

        <dt id="eventterm-typedliteral-string-value">string-value</dt>
        <dd>
          <p>The value is the concatenation of the following in this order
            "&quot;" (1 double quote),
            the escaped value of the
            <a href="#eventterm-typedliteral-literal-value"
            class="termref"><span
            class="arrow">·</span>literal-value<span
            class="arrow">·</span></a> accessor,
            "&quot;" (1 double quote),  "^^&lt;",
            the escaped value of the
            <a href="#eventterm-typedliteral-literal-datatype"
            class="termref"><span
            class="arrow">·</span>literal-datatype<span
            class="arrow">·</span></a> accessor
            and "&gt;".
          </p>

          <p>The escaping of the <a
            href="#eventterm-typedliteral-literal-value"
            class="termref"><span
            class="arrow">·</span>literal-value<span
            class="arrow">·</span></a> accessor value
            uses the N-Triples
            escapes for strings [[RDF12-N-TRIPLES]]
            for escaping certain characters such as &quot;.
            The escaping of the <a
            href="#eventterm-typedliteral-literal-datatype"
            class="termref"><span
            class="arrow">·</span>literal-datatype<span
            class="arrow">·</span></a> accessor value
            must use the N-Triples escapes for IRI [[RDF12-N-TRIPLES]].</p>

        </dd>
      </dl>

      <p>These events are constructed by giving values for the
        <a href="#eventterm-typedliteral-literal-value"
        class="termref"><span class="arrow">·</span>literal-value<span
        class="arrow">·</span></a>
        and <a href="#eventterm-typedliteral-literal-datatype"
        class="termref"><span
        class="arrow">·</span>literal-datatype<span
        class="arrow">·</span></a> accessors.</p>

      <p id="literal-comb-char-note2" class="note">
        <strong>Interoperability Note (Informative):</strong>
        Literals beginning with a Unicode combining character are
        allowed however they may cause interoperability problems.
        See [[CHARMOD]] for further information.
      </p>

      <p class="note" id="literal-white-space-normalization-note">
        <strong>Implementation Note (Informative): </strong>
        In XML Schema (part 1) [[XMLSCHEMA-1]],
        <a data-cite="XMLSCHEMA-1#d0e1654">
          white space normalization
        </a>
        occurs during validation according to the value of the whiteSpace
        facet.  The syntax mapping used in this document occurs after this,
        so the whiteSpace facet formally has no further effect.
      </p>
    </section>

  </section>

  <!-- infoset mapping -->
  <section id="section-Infoset-Mapping">
    <h3 id="section-Infoset-Conformance">Information Set Mapping</h3>

    <p>To transform the Infoset into the sequence of events
      in <em>document order</em>, each
      information item is transformed as described above to generate a
      tree of events with accessors and values.  Each element event is
      then replaced as described below to turn the tree of events
      into a sequence in document order.</p>

    <ol>
      <li>The original <a href="#section-element-node">element event</a></li>
      <li>The value of the
      <a data-cite="XML-INFOSET#infoitem.element">children</a>
      accessor recursively transformed, a possibly empty ordered list of events.</li>
      <li>An <a href="#section-end-element-node">end element event</a></li>
    </ol>
  </section>


  <!-- grammar notation -->
  <section id="section-Infoset-Grammar-Notation">
    <h3 id="section-Notation-Forms">Grammar Notation</h3>

    <p>The following notation is used to describe matching the sequence
      of data model events as given in <a href="#section-Data-Model" class="sectionRef"></a>
      and the actions to perform for the matches.
      The RDF/XML grammar is defined in terms of mapping from these matched
      data model events to triples, using notation of the form:</p>

    <blockquote>
      <div class="productionOuter">
        <div class="productionInner">
          <p>number <em>event-type</em> <em>event-content</em></p>
        </div>
      </div>

      <div>
        <em>action</em>...
        <div class="ntripleOuter">
          <div class="ntripleInner">
            <p><code>N-Triples</code></p>
          </div>
        </div>
      </div>
    </blockquote>

    <p>where the <em>event-content</em> is an expression matching
      <em>event-types</em> (as defined in <a href="#section-Nodes" class="sectionRef"></a>),
      using notation given in the following sections.
      The number is used for reference purposes.
      The grammar <em>action</em> may include generating
      new triples to the graph, written in N-Triples [[RDF12-N-TRIPLES]]
      format.
    </p>

    <p>The following sections describe the general notation used and that
      for event matching and actions.</p>

    <!-- general grammar notation -->
    <section id="section-Infoset-Grammar-General">
      <h4>Grammar General Notation</h4>

      <table>
        <tr>
        <th>Notation</th>
        <th>Meaning</th>
        </tr>
        <tr>
        <td><em>event</em>.<em>accessor</em></td>

        <td>The value of an event accessor.</td>
        </tr>
        <tr>
        <td><code>rdf:</code><em>X</em></td>
        <td>A URI as defined in <a href="#section-Namespace" class="sectionRef"></a>.</td>
        </tr>
        <tr>
        <td>"ABC"</td>
        <td>A string of characters A, B, C in order.</td>

        </tr>
      </table>
    </section>


    <!-- grammar event matching notation -->
    <section id="section-Infoset-Grammar-Matching">
      <h4>Grammar Event Matching Notation</h4>

      <table>
        <tr>
        <th>Notation</th>
        <th>Meaning</th>
        </tr>
        <tr>
        <td>A == B</td>
        <td>Event accessor A matches expression B.</td>
        </tr>
        <tr>
        <td>A != B</td>
        <td>A is not equal to B.</td>
        </tr>
        <tr>
        <td>A | B | ...</td>
        <td>The A, B, ... terms are alternatives.</td>
        </tr>
        <tr>
        <td>A - B</td>
        <td>The terms in A excluding all the terms in B.</td>
        </tr>
        <tr>
        <td><dfn>anyURI</dfn>.</td>
        <td>Any URI.</td>
        </tr>
        <tr>
        <td><dfn>anyString</dfn>.</td>
        <td>Any string.</td>
        </tr>
        <tr>
        <td>list(item1, item2, ...); list()</td>
        <td>An ordered list of events. An empty list.</td>
        </tr>
        <tr>
        <td>set(item1, item2, ...); set()</td>
        <td>An unordered set of events.  An empty set.</td>
        </tr>
        <tr>
        <td>*</td>
        <td>Zero or more of preceding term.</td>
        </tr>
        <tr>
        <td>?</td>
        <td>Zero or one of preceding term.</td>
        </tr>
        <tr>
        <td>+</td>
        <td>One or more of preceding term.</td>
        </tr>
        <tr>
        <td>root(acc1 == value1,<br />
        &#160;&#160;&#160;&#160;acc2 == value2, ...)</td>
        <td>Match a <a href="#section-root-node">Root Event</a> with accessors.
        </td>
        </tr>
        <tr>
        <td>start-element(acc1 == value1,<br />
        &#160;&#160;&#160;&#160;acc2 == value2, ...)<br />
        <em>children</em><br />
        end-element()</td>
        <td>Match a sequence of
        <a href="#section-element-node">Element Event</a> with accessors,
        a possibly empty list of events as element content and an
        <a href="#section-end-element-node">End Element Event</a>.
        </td>
        </tr>
        <tr>
        <td>attribute(acc1 == value1,<br />
        &#160;&#160;&#160;&#160;acc2 == value2, ...)</td>
        <td>Match an <a href="#section-attribute-node">Attribute Event</a>
        with accessors.</td>
        </tr>
        <tr>
        <td>text()</td>
        <td>Match a <a href="#section-text-node">Text Event</a>.</td>
        </tr>
      </table>
    </section>


    <!-- grammar action notation -->
    <section id="section-Infoset-Grammar-Action">
      <h4>Grammar Action Notation</h4>

      <table>
      <tr>
      <th>Notation</th>
      <th>Meaning</th>
      </tr>
      <tr>
      <td>A := B</td>
      <td>Assigns A the value B.</td>
      </tr>
      <tr>
      <td>concat(A, B, ..)</td>
      <td>A string created by concatenating the terms in order.</td>
      </tr>
      <tr>
      <td>resolve(<em>e</em>, <em>s</em>)</td>
      <td>A string created by interpreting string <em>s</em> as a relative IRI to the
      <a href="#eventterm-element-base-uri" class="termref"><span class="arrow">·</span>base-uri<span class="arrow">·</span></a> accessor of <a href="#section-element-node"><em>e</em></a>
      as defined in <a href="#section-baseURIs" class="sectionRef"></a>.
      The resulting string represents an
      IRI.</td>
      </tr>
      <tr>
      <td>generated-blank-node-id()</td>
      <td>A string value for a new distinct generated
      blank node identifier
      as defined in <a href="#section-Identifiers" class="sectionRef"></a>.
      </td>
      </tr>
      <tr>
      <td><em>event</em>.<em>accessor</em> := <em>value</em></td>
      <td>Sets an event accessor to the given value.</td>
      </tr>
      <tr>
      <td>uri(identifier := value)</td>
      <td>Create a new <a href="#section-identifier-node">URI Reference Event</a>.</td>
      </tr>
      <tr>
      <td>bnodeid(identifier := value)</td>
      <td>Create a new <a href="#section-blank-nodeid-event">Blank Node Identifier Event</a>.
        See also section <a href="#section-Identifiers" class="sectionRef"></a>.</td>
      </tr>
      <tr>
      <td>literal(literal-value := string,<br />
      &#160;&#160;&#160;&#160;literal-language := language, ...)</td>
      <td>Create a new <a href="#section-literal-node">Plain Literal Event</a>.</td>
      </tr>
      <tr>
      <td>typed-literal(literal-value := string, ...)</td>
      <td>Create a new <a href="#section-typed-literal-node">Typed Literal Event</a>.</td>
      </tr>
      </table>
    </section>
  </section>
</section>

<!-- SIXTH PART : RDF/XML grammar -->
<section id="section-Infoset-Grammar">
    <h2>RDF/XML Grammar</h2>


    <!-- grammar summary -->
    <section id="section-grammar-summary">
    <h3>Grammar summary</h3>

    <div class="productionOuter"><div class="productionInner">
    <table>
    <tr>
    <td><a href="#coreSyntaxTerms">7.2.2</a> <a href="#coreSyntaxTerms">coreSyntaxTerms</a></td> <td><code>rdf:RDF</code> | <code>rdf:ID</code> | <code>rdf:about</code> | <code>rdf:parseType</code> | <code>rdf:resource</code> | <code>rdf:nodeID</code> | <code>rdf:datatype</code></td>

    </tr>
    <tr>
    <td><a href="#syntaxTerms">7.2.3</a> <a href="#syntaxTerms">syntaxTerms</a></td> <td><a href="#coreSyntaxTerms">coreSyntaxTerms</a> | <code>rdf:Description</code> | <code>rdf:li</code></td>
    </tr>
    <tr>
    <td><a href="#oldTerms">7.2.4</a> <a href="#oldTerms">oldTerms</a></td> <td><code>rdf:aboutEach</code> | <code>rdf:aboutEachPrefix</code> | <code>rdf:bagID</code></td>

    </tr>
    <tr>
    <td><a href="#nodeElementURIs">7.2.5</a> <a href="#nodeElementURIs">nodeElementURIs</a></td> <td><a>anyURI</a> - ( <a href="#coreSyntaxTerms">coreSyntaxTerms</a> | <code>rdf:li</code> | <a href="#oldTerms">oldTerms</a> )</td>

    </tr>
    <tr>
    <td><a href="#propertyElementURIs">7.2.6</a> <a href="#propertyElementURIs">propertyElementURIs</a></td> <td><a>anyURI</a> - ( <a href="#coreSyntaxTerms">coreSyntaxTerms</a> | <code>rdf:Description</code> | <a href="#oldTerms">oldTerms</a> )</td>

    </tr>
    <tr>
    <td><a href="#propertyAttributeURIs">7.2.7</a> <a href="#propertyAttributeURIs">propertyAttributeURIs</a></td> <td><a>anyURI</a> - ( <a href="#coreSyntaxTerms">coreSyntaxTerms</a>  | <code>rdf:Description</code> | <code>rdf:li</code> | <a href="#oldTerms">oldTerms</a> )</td>

    </tr>
    <tr>
    <td><a href="#doc">7.2.8</a> <a href="#doc">doc</a></td> <td>root(<a href="#eventterm-root-document-element">document-element</a> == <a href="#RDF">RDF</a>,
    <a href="#eventterm-root-children">children</a> == list(<a href="#RDF">RDF</a>))</td>

    </tr>
    <tr>
    <td><a href="#RDF">7.2.9</a> <a href="#RDF">RDF</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <code>rdf:RDF</code>,
    <a href="#eventterm-element-attributes">attributes</a> == set())<br />
    <a href="#nodeElementList">nodeElementList</a><br />

    end-element()</td>
    </tr>
    <tr>
    <td><a href="#nodeElementList">7.2.10</a> <a href="#nodeElementList">nodeElementList</a></td> <td><a href="#ws">ws</a>* (<a href="#nodeElement">nodeElement</a> <a href="#ws">ws</a>* )*</td>
    </tr>
    <tr>

    <td><a href="#nodeElement">7.2.11</a> <a href="#nodeElement">nodeElement</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#nodeElementURIs">nodeElementURIs</a><br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set((<a href="#idAttr">idAttr</a> | <a href="#nodeIdAttr">nodeIdAttr</a> | <a href="#aboutAttr">aboutAttr</a> )?, <a href="#propertyAttr">propertyAttr</a>*))<br />

    <a href="#propertyEltList">propertyEltList</a><br />
    end-element()</td>
    </tr>
    <tr>
    <td><a href="#ws">7.2.12</a> <a href="#ws">ws</a></td> <td>A
    <a href="#section-text-node">text event</a> matching white
    space defined by XML [[XML10]] definition <em>White Space</em>

    Rule [3] <a data-cite="XML10#NT-S">S</a>
    in section
    <a data-cite="XML10#sec-common-syn">Common Syntactic Constructs</a></td>
    </tr>
    <tr>
    <td><a href="#propertyEltList">7.2.13</a> <a href="#propertyEltList">propertyEltList</a></td> <td><a href="#ws">ws</a>* (<a href="#propertyElt">propertyElt</a> <a href="#ws">ws</a>* ) *</td>

    </tr>
    <tr>
    <td><a href="#propertyElt">7.2.14</a> <a href="#propertyElt">propertyElt</a></td> <td><a href="#resourcePropertyElt">resourcePropertyElt</a> |
    <a href="#literalPropertyElt">literalPropertyElt</a> |
    <a href="#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a> |
    <a href="#parseTypeResourcePropertyElt">parseTypeResourcePropertyElt</a> |

    <a href="#parseTypeCollectionPropertyElt">parseTypeCollectionPropertyElt</a> |
    <a href="#parseTypeOtherPropertyElt">parseTypeOtherPropertyElt</a> |
    <a href="#emptyPropertyElt">emptyPropertyElt</a></td>
    </tr>
    <tr>
    <td><a href="#resourcePropertyElt">7.2.15</a> <a href="#resourcePropertyElt">resourcePropertyElt</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),

    <a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?))<br />
    <a href="#ws">ws</a>* <a href="#nodeElement">nodeElement</a> <a href="#ws">ws</a>*<br />
    end-element()</td>
    </tr>
    <tr>

    <td><a href="#literalPropertyElt">7.2.16</a> <a href="#literalPropertyElt">literalPropertyElt</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),
    <a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#datatypeAttr">datatypeAttr</a>?))<br />

    <a href="#section-text-node">text()</a><br />
    end-element()</td>
    </tr>
    <tr>
    <td><a href="#parseTypeLiteralPropertyElt">7.2.17</a> <a href="#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),

    <a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseLiteral">parseLiteral</a>))<br />
    <a href="#literal">literal</a><br />
    end-element()</td>
    </tr>
    <tr>
    <td><a href="#parseTypeResourcePropertyElt">7.2.18</a> <a href="#parseTypeResourcePropertyElt">parseTypeResourcePropertyElt</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),

    <a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseResource">parseResource</a>))<br />
    <a href="#propertyEltList">propertyEltList</a><br />
    end-element()</td>
    </tr>
    <tr>
    <td><a href="#parseTypeCollectionPropertyElt">7.2.19</a> <a href="#parseTypeCollectionPropertyElt">parseTypeCollectionPropertyElt</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),

    <a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseCollection">parseCollection</a>))<br />
    <a href="#nodeElementList">nodeElementList</a><br />
    end-element()</td>
    </tr>
    <tr>
    <td><a href="#parseTypeOtherPropertyElt">7.2.20</a> <a href="#parseTypeOtherPropertyElt">parseTypeOtherPropertyElt</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),

    <a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseOther">parseOther</a>))<br />
    <a href="#propertyEltList">propertyEltList</a><br />
    end-element()</td>
    </tr>
    <tr>
    <td><a href="#emptyPropertyElt">7.2.21</a> <a href="#emptyPropertyElt">emptyPropertyElt</a></td> <td>start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),

    <a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, ( <a href="#resourceAttr">resourceAttr</a> | <a href="#nodeIdAttr">nodeIdAttr</a> | <a href="#datatypeAttr">datatypeAttr</a> )?, <a href="#propertyAttr">propertyAttr</a>*))<br />
    end-element()</td>
    </tr>

    <tr>
    <td><a href="#idAttr">7.2.22</a> <a href="#idAttr">idAttr</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:ID</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == <a href="#rdf-id">rdf-id</a>)</td>

    </tr>
    <tr>
    <td><a href="#nodeIdAttr">7.2.23</a> <a href="#nodeIdAttr">nodeIdAttr</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:nodeID</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == <a href="#rdf-id">rdf-id</a>)</td>

    </tr>
    <tr>
    <td><a href="#aboutAttr">7.2.24</a> <a href="#aboutAttr">aboutAttr</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:about</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == <a href="#URI-reference">URI-reference</a>)</td>

    </tr>
    <tr>
    <td><a href="#propertyAttr">7.2.25</a> <a href="#propertyAttr">propertyAttr</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <a href="#propertyAttributeURIs">propertyAttributeURIs</a>,
    <a href="#eventterm-attribute-string-value">string-value</a> == <a>anyString</a>)</td>

    </tr>
    <tr>
    <td><a href="#resourceAttr">7.2.26</a> <a href="#resourceAttr">resourceAttr</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:resource</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == <a href="#URI-reference">URI-reference</a>)</td>

    </tr>
    <tr>
    <td><a href="#datatypeAttr">7.2.27</a> <a href="#datatypeAttr">datatypeAttr</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:datatype</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == <a href="#URI-reference">URI-reference</a>)</td>

    </tr>
    <tr>
    <td><a href="#parseLiteral">7.2.28</a> <a href="#parseLiteral">parseLiteral</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == "Literal")</td>
    </tr>

    <tr>
    <td><a href="#parseResource">7.2.29</a> <a href="#parseResource">parseResource</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == "Resource")</td>
    </tr>
    <tr>

    <td><a href="#parseCollection">7.2.30</a> <a href="#parseCollection">parseCollection</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,
    <a href="#eventterm-attribute-string-value">string-value</a> == "Collection")</td>
    </tr>
    <tr>
    <td><a href="#parseOther">7.2.31</a> <a href="#parseOther">parseOther</a></td> <td>attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,

    <a
    href="#eventterm-attribute-string-value">string-value</a> == <a>anyString</a> - ("Resource" | "Literal" | "Collection") )</td>
    </tr>
    <tr>
    <td><a href="#URI-reference">7.2.32</a> <a href="#URI-reference">URI-reference</a></td> <td>An IRI.</td>

    </tr>
    <tr>
    <td><a href="#literal">7.2.33</a> <a
    href="#literal">literal</a></td> <td>Any XML element content
    that is allowed according to
    [[XML10]] definition <em>Content of Elements</em>
    Rule [43]
    <a data-cite="XML10#NT-content">content</a>.
    in section
    <a data-cite="XML10#sec-starttags">3.1 Start-Tags, End-Tags, and Empty-Element Tags</a></td>

    </tr>
    <tr>
    <td><a href="#rdf-id">7.2.34</a> <a href="#rdf-id">rdf-id</a></td> <td>An attribute <a href="#eventterm-attribute-string-value" class="termref"><span class="arrow">·</span>string-value<span class="arrow">·</span></a>
    matching any legal [[XML-NAMES]] token
    <a data-cite="XML-NAMES/#NT-NCName">NCName</a></td>

    </tr>
    </table>

    </div></div>
    </section>

    <!-- grammar productions -->
    <section id="section-grammar-productions">
    <h3>Grammar Productions</h3>

    <!-- grammar start -->
    <section id="start">
    <h4>Grammar start</h4>

    <p>If the RDF/XML is a standalone XML document
    (identified by presentation as an
    application/rdf+xml <a href="#section-MIME-Type">RDF MIME type</a> object,
    or by some other means) then the grammar may start with
    production <a href="#doc">doc</a> or
    production <a href="#nodeElement">nodeElement</a>.</p>

    <p>If the content is known to be RDF/XML by context, such as when
    RDF/XML is embedded inside other XML content, then the grammar
    can either start
    at <a href="#section-element-node">Element Event</a>&#160;
    <a href="#RDF">RDF</a>
    (only when an element is legal at that point in the XML)
    or at production <a href="#nodeElementList">nodeElementList</a>
    (only when element content is legal, since this is a list of elements).
    For such embedded RDF/XML, the
    <a href="#eventterm-element-base-uri" class="termref"><span class="arrow">·</span>base-uri<span class="arrow">·</span></a>
    value on the outermost element must be initialized from the containing
    XML since no
    <a href="#section-root-node">Root Event</a>&#160; will be available.
    Note that if such embedding occurs, the grammar may be entered
    several times but no state is expected to be preserved.</p>
    </section>

    <!-- core syntax terms -->
    <section id="coreSyntaxTerms">
    <h4>Production coreSyntaxTerms</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <code>rdf:RDF</code> | <code>rdf:ID</code> | <code>rdf:about</code> | <code>rdf:parseType</code> | <code>rdf:resource</code> | <code>rdf:nodeID</code> | <code>rdf:datatype</code>

    </p></div></div>

    <p>A subset of the syntax terms from the RDF vocabulary in
    <a href="#section-Namespace" class="sectionRef"></a>
    which are used in RDF/XML.
    </p>
    </section>

    <!-- syntax terms -->
    <section id="syntaxTerms">
    <h4>Production syntaxTerms</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <a href="#coreSyntaxTerms">coreSyntaxTerms</a> | <code>rdf:Description</code> | <code>rdf:li</code>

    </p></div></div>

    <p>All the syntax terms from the RDF vocabulary in
    <a href="#section-Namespace" class="sectionRef"></a>
    which are used in RDF/XML.
    </p>
    </section>

    <!-- old terms -->
    <section id="oldTerms">
    <h4 id="section-Bag-Expand" >Production oldTerms</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <code>rdf:aboutEach</code> | <code>rdf:aboutEachPrefix</code> | <code>rdf:bagID</code>

    </p></div></div>

    <p>These are the names from the <a>RDF vocabulary</a>
    that have been withdrawn from the language.  See the resolutions of
    Issue <a href="https://www.w3.org/2000/03/rdf-tracking/#rdfms-aboutEach-on-object">rdfms-aboutEach-on-object</a>,
    Issue <a href="https://www.w3.org/2000/03/rdf-tracking/#rdfms-abouteachprefix">rdfms-abouteachprefix</a> and
    Last Call Issue <a href="https://www.w3.org/2001/sw/RDFCore/20030123-issues/#timbl-01">timbl-01</a>
    for further information.
    </p>

    <p class="note"><strong>Error Test:</strong>
    Indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-abouteach/error001.rdf">error001.rdf</a> and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-abouteach/error002.rdf">error002.rdf</a>
    </p>
    </section>

    <!-- node element uri -->
    <section id="nodeElementURIs">
    <h4>Production nodeElementURIs</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <a>anyURI</a> - ( <a href="#coreSyntaxTerms">coreSyntaxTerms</a> | <code>rdf:li</code> | <a href="#oldTerms">oldTerms</a> )

    </p></div></div>

    <p>The IRIs that are allowed on node elements.</p>
    </section>

    <!-- property element URIs -->
    <section id="propertyElementURIs">
    <h4>Production propertyElementURIs</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <a>anyURI</a> - ( <a href="#coreSyntaxTerms">coreSyntaxTerms</a> | <code>rdf:Description</code> | <a href="#oldTerms">oldTerms</a> )

    </p></div></div>

    <p>The URIs that are allowed on property elements.</p>
    </section>

    <!-- property attribute URIs -->
    <section id="propertyAttributeURIs">
    <h4>Production propertyAttributeURIs</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <a>anyURI</a> - ( <a href="#coreSyntaxTerms">coreSyntaxTerms</a>  | <code>rdf:Description</code> | <code>rdf:li</code> | <a href="#oldTerms">oldTerms</a> )

    </p></div></div>

    <p>The IRIs that are allowed on property attributes.</p>
    </section>

    <!-- production doc -->
    <section id="doc">
    <h4>Production doc</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    root(<a href="#eventterm-root-document-element">document-element</a> == <a href="#RDF">RDF</a>,<br />

    &#160;&#160;&#160;&#160;<a href="#eventterm-root-children">children</a> == list(<a href="#RDF">RDF</a>))
    </p></div></div>
    </section>

    <!-- production RDF -->
    <section id="RDF">
    <h4>Production RDF</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <code>rdf:RDF</code>,<br />

    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set())<br />
    <a href="#nodeElementList">nodeElementList</a><br />
    end-element()
    </p></div></div>
    </section>

    <!-- node element list -->
    <section id="nodeElementList">
    <h4>Production nodeElementList</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <a href="#ws">ws</a>* (<a href="#nodeElement">nodeElement</a> <a href="#ws">ws</a>* )*

    </p></div></div>
    </section>

    <!-- production node element -->
    <section id="nodeElement">
    <h4 id="typedNode">Production nodeElement</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#nodeElementURIs">nodeElementURIs</a><br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set((<a href="#idAttr">idAttr</a> | <a href="#nodeIdAttr">nodeIdAttr</a> | <a href="#aboutAttr">aboutAttr</a> )?, <a href="#propertyAttr">propertyAttr</a>*))<br />

    <a href="#propertyEltList">propertyEltList</a><br />
    end-element()
    </p></div></div>

    <p>For node element <em>e</em>, the processing of some of the attributes
    has to be done before other work such as dealing with children events
    or other attributes.  These can be processed in any order:</p>

    <ul>

    <li>If there is an attribute <em>a</em> with
     <em>a</em>.<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:ID</code>, then

    <em>e</em>.<a href="#eventterm-element-subject">subject</a> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>))).</li>

    <li>If there is an attribute <em>a</em> with
     <em>a</em>.<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:nodeID</code>, then

    <em>e</em>.<a href="#eventterm-element-subject">subject</a> := bnodeid(<a href="#eventterm-identifier-identifier">identifier</a>:=<em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>).</li>

    <li>If there is an attribute <em>a</em> with

    <em>a</em>.<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:about</code> then
    <em>e</em>.<a href="#eventterm-element-subject">subject</a> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>)).</li>

    </ul>

    <p>If <em>e</em>.<a href="#eventterm-element-subject">subject</a> is empty,
    then <em>e</em>.<a href="#eventterm-element-subject">subject</a> := bnodeid(<a href="#eventterm-identifier-identifier">identifier</a> := generated-blank-node-id()).</p>


    <p>The following can then be performed in any order:</p>

    <ul>

    <li id="nodeElementStatement1"> If <em>e</em>.<a
    href="#eventterm-element-URI">URI</a> !=
    <code>rdf:Description</code>
    then the following statement is added to the graph:


    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> .</code>
    </p></div></div>
    </li>

    <li id="nodeElementStatement2"> If there is an attribute <em>a</em>
    in <a href="#propertyAttr">propertyAttr</a> with
    <em>a</em>.<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:type</code>
    then

    <em>u</em>:=uri(identifier:=resolve(<em>e</em>, <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>))
    and the following triple is added to the graph:
    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; <em>u</em>.<a href="#eventterm-identifier-string-value">string-value</a> .</code>

    </p></div></div>
    </li>

    <li id="nodeElementStatement3"> For each attribute <em>a</em> matching
    <a href="#propertyAttr">propertyAttr</a> (and not <code>rdf:type</code>),
    the Unicode string
    <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>

    SHOULD be in Normal Form C [[NFC]],
    <em>o</em> := literal(<a href="#eventterm-literal-literal-value">literal-value</a> := <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>, <a href="#eventterm-literal-literal-language">literal-language</a> := <em>e</em>.<a href="#eventterm-element-language">language</a>)
    and the following statement is added to the graph:


    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>a</em>.<a href="#eventterm-attribute-URI-string-value">URI-string-value</a> <em>o</em>.<a href="#eventterm-literal-string-value">string-value</a> .</code>

    </p></div></div>
    </li>

    <li id="nodeElementStatement4"> Handle the
    <a href="#propertyEltList">propertyEltList</a> children events
    in document order.</li>

    </ul>
    </section>

    <!-- production ws -->
    <section id="ws">
    <h4>Production ws</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    A <a href="#section-text-node">text event</a> matching white space
    defined by [[XML10]] definition <em>White Space</em>
    Rule [3] <a data-cite="XML10#NT-S">S</a>
    in section
    <a data-cite="XML10#sec-common-syn">Common Syntactic Constructs</a>
    </p></div></div>
    </section>

    <!-- property elt list -->
    <section id="propertyEltList">
    <h4>Production propertyEltList</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <a href="#ws">ws</a>* (<a href="#propertyElt">propertyElt</a> <a href="#ws">ws</a>* ) *
    </p></div></div>
    </section>

    <!-- property elt -->
    <section id="propertyElt">
    <h4>Production propertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    <a href="#resourcePropertyElt">resourcePropertyElt</a> |
    <a href="#literalPropertyElt">literalPropertyElt</a> |
    <a href="#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a> |
    <a href="#parseTypeResourcePropertyElt">parseTypeResourcePropertyElt</a> |
    <a href="#parseTypeCollectionPropertyElt">parseTypeCollectionPropertyElt</a> |

    <a href="#parseTypeOtherPropertyElt">parseTypeOtherPropertyElt</a> |
    <a href="#emptyPropertyElt">emptyPropertyElt</a>
    </p></div></div>

    <p>If element <em>e</em> has
    <em>e</em>.<a href="#eventterm-element-URI">URI</a> =
    <code>rdf:li</code> then apply the list expansion rules on element <em>e</em>.parent in

    <a href="#section-List-Expand" class="sectionRef"></a>
    to give a new URI <em>u</em> and
    <em>e</em>.<a href="#eventterm-element-URI">URI</a> := <em>u</em>.
    </p>

    <p>The action of this production must be done before the
    actions of any sub-matches (<a
    href="#resourcePropertyElt">resourcePropertyElt</a> ... <a href="#emptyPropertyElt">emptyPropertyElt</a>).
    Alternatively the result must be equivalent to as if it this action
    was performed first, such as performing as the first
    action of all of the sub-matches.
    </p>
    </section>

    <!-- resource property element -->
    <section id="resourcePropertyElt">
    <h4>Production resourcePropertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?))<br />

    <a href="#ws">ws</a>* <a href="#nodeElement">nodeElement</a> <a href="#ws">ws</a>*<br />
    end-element()
    </p></div></div>

    <p>For element <em>e</em>, and the single contained nodeElement
    <em>n</em>, first <em>n</em> must be processed using production

    <a href="#nodeElement">nodeElement</a>.
    Then the following statement is added to the graph:</p>

    <div class="ntripleOuter"><div class="ntripleInner"><p>
    &#160;&#160;<code> <em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> <em>n</em>.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> .</code>

    </p></div></div>

    <p>If the <code>rdf:ID</code> attribute <em>a</em> is given, the above
    statement is reified with
    <em>i</em> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>)))
    using the reification rules in

    <a href="#section-Reification" class="sectionRef"></a>
    and <em>e</em>.<a href="#eventterm-element-subject">subject</a> := <em>i</em></p>
    </section>

    <!-- literal property element -->
    <section id="literalPropertyElt">
    <h4>Production literalPropertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),<br />

    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#datatypeAttr">datatypeAttr</a>?))<br />
    <a href="#section-text-node">text()</a><br />
    end-element()
    </p></div></div>

    <p>Note that the empty literal case is defined in production
    <a href="#emptyPropertyElt">emptyPropertyElt</a>.</p>

    <p>For element <em>e</em>, and the text event <em>t</em>.
    The Unicode string <em>t</em>.<a
    href="#eventterm-text-string-value">string-value</a> SHOULD be
    in Normal Form C [[NFC]].
    If the <code>rdf:datatype</code> attribute <em>d</em> is given
    then <em>o</em> := typed-literal(<a href="#eventterm-typedliteral-literal-value">literal-value</a> := <em>t</em>.<a href="#eventterm-text-string-value">string-value</a>, <a href="#eventterm-typedliteral-literal-datatype">literal-datatype</a> := <em>d</em>.<a href="#eventterm-attribute-string-value">string-value</a>)
    otherwise

    <em>o</em> := literal(<a href="#eventterm-literal-literal-value">literal-value</a> := <em>t</em>.<a href="#eventterm-text-string-value">string-value</a>, <a href="#eventterm-literal-literal-language">literal-language</a> := <em>e</em>.<a href="#eventterm-element-language">language</a>)
    and the following statement is added to the graph:</p>

    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> <em>o</em>.<a href="#eventterm-literal-string-value">string-value</a> .</code>

    </p></div></div>

    <p>If the <code>rdf:ID</code> attribute <em>a</em> is given, the above
    statement is reified with
    <em>i</em> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>)))
    using the reification rules in

    <a href="#section-Reification" class="sectionRef"></a>
    and <em>e</em>.<a href="#eventterm-element-subject">subject</a> := <em>i</em>.</p>
    </section>

    <!-- parse type literal property element -->
    <section id="parseTypeLiteralPropertyElt" class="informative">
    <h4>Production parseTypeLiteralPropertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>

    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseLiteral">parseLiteral</a>))<br />
    <a href="#literal">literal</a><br />

    end-element()
    </p></div></div>


    <p>For element <em>e</em> and the literal <em>l</em>
    that is the <code>rdf:parseType="Literal"</code> content.
    <em>l</em> is not transformed by the syntax data model mapping into events
    (as noted in section <a href="#section-Data-Model" class="sectionRef"></a>)
    but remains an XML Infoset of XML Information items.</p>

    <p><em>l</em> is transformed into the lexical form of an
    <a data-cite="RDF12-CONCEPTS#dfn-rdf-xmlliteral">XML literal</a>
    in the RDF graph <em>x</em> (a Unicode string)
    by the following algorithm.  This does not mandate any implementation
    method &mdash; any other method that gives the same result may be used.</p>

    <ol>
<!-- old algorithm
<li>Use <em>l</em> to construct an XPath <a
    data-cite="XPATH#infoset">node-set</a>
    (a <a data-cite="XML-EXC-C14N#def-document-subset">document
    subset</a>)</li>
    <li>Apply [[[XML-EXC-C14N]]] [[XML-EXC-C14N]])
    with comments and with empty
    <a data-cite="XML-EXC-C14N#def-InclusiveNamespaces-PrefixList">InclusiveNamespaces PrefixList</a>
    to this node-set to give a sequence of octets <em>s</em>
    </li>
    <li>This sequence of octets <em>s</em> can be considered to be
    a UTF-8 encoding of some Unicode string <em>x</em> (sequence
    of Unicode characters)</li>
    -->
<li>Use <em>l</em> to construct an <a
data-cite="XPATH-DATAMODEL-30#sequences">XPath
sequence</a> [[XPATH-DATAMODEL-30]].</li>
    <li>Apply <a
data-cite="XPATH-FUNCTIONS-30#func-serialize">https://www.w3.org/TR/xpath-functions-30/#func-serialize</a> [[XPATH-FUNCTIONS-30]]
to this sequence to give an xsd:string <em>x</em>.</li>
    <li>The Unicode string <em>x</em> is used as the lexical form of <em>l</em></li>
    <li>This Unicode string <em>x</em> SHOULD be in NFC Normal Form C [[NFC]]</li>
    </ol>

    <p>Then <em>o</em> := typed-literal(<a href="#eventterm-typedliteral-literal-value">literal-value</a> := <em>x</em>, <a href="#eventterm-typedliteral-literal-datatype">literal-datatype</a> := <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral</code> )
    and the following statement is added to the graph:</p>

    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> <em>o</em>.<a href="#eventterm-typedliteral-string-value">string-value</a> .</code>

    </p></div></div>

    <p class="note"><strong>Test:</strong>
    Empty literal case indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test009.rdf">test009.rdf</a>
    and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test009.nt">test009.nt</a>
    </p>

    <p>If the <code>rdf:ID</code> attribute <em>a</em> is given, the above
    statement is reified with

    <em>i</em> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>)))
    using the reification rules in
    <a href="#section-Reification" class="sectionRef"></a>
    and <em>e</em>.<a href="#eventterm-element-subject">subject</a> := <em>i</em>.</p>
    </section>

    <!-- parse type resource property element -->
    <section id="parseTypeResourcePropertyElt">
    <h4>Production parseTypeResourcePropertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseResource">parseResource</a>))<br />

    <a href="#propertyEltList">propertyEltList</a><br />
    end-element()
    </p></div></div>

    <p>For element <em>e</em> with possibly empty element content <em>c</em>.</p>

    <p><em>n</em> := bnodeid(<a href="#eventterm-identifier-identifier">identifier</a> := generated-blank-node-id()).</p>

    <p>Add the following statement to the graph:
    </p>
    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> <em>n</em>.<a href="#eventterm-identifier-string-value">string-value</a> .</code>

    </p></div></div>

    <p class="note"><strong>Test:</strong>
    Indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test004.rdf">test004.rdf</a>
    and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test004.nt">test004.nt</a>
    </p>

    <p>If the <code>rdf:ID</code> attribute <em>a</em> is given, the
    statement above is reified with

    <em>i</em> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>)))
    using the reification rules in
    <a href="#section-Reification" class="sectionRef"></a>
    and <em>e</em>.<a href="#eventterm-element-subject">subject</a> := <em>i</em>.</p>

    <p>If the element content <em>c</em> is not empty, then use event
    <em>n</em> to create a new sequence of events as follows:</p>
    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> := <code>rdf:Description</code>,<br />

    &#160;&#160;&#160;&#160;<a href="#eventterm-element-subject">subject</a> := <em>n</em>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> := set())<br />
      <em>c</em><br />
    end-element()
    </p></div></div>

    <p>Then
    process the resulting sequence using production

    <a href="#nodeElementList">nodeElement</a>.</p>
    </section>

    <!-- parse type collection property element -->
    <section id="parseTypeCollectionPropertyElt">
    <h4>Production parseTypeCollectionPropertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),<br />

    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseCollection">parseCollection</a>))<br />
    <a href="#nodeElementList">nodeElementList</a><br />
    end-element()
    </p></div></div>

    <p>For element event <em>e</em> with possibly empty

    <a href="#nodeElementList">nodeElementList</a> <em>l</em>.  Set
    <em>s</em>:=list().</p>

    <p>For each element event <em>f</em> in <em>l</em>,
    <em>n</em> := bnodeid(<a href="#eventterm-identifier-identifier">identifier</a> := generated-blank-node-id()) and append <em>n</em> to

    <em>s</em> to give a sequence of events.</p>

    <p>If <em>s</em> is not empty, <em>n</em> is the first event identifier in
    <em>s</em> and the following statement is added to the graph:</p>
    <div class="ntripleOuter"><div class="ntripleInner"><p>

    <code><em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> <em>n</em>.<a href="#eventterm-identifier-string-value">string-value</a> .</code>
    </p></div></div>

    <p>otherwise the following statement is added to the graph:</p>
    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#nil&gt; .</code>

    </p></div></div>

    <p>If the <code>rdf:ID</code> attribute <em>a</em> is given,
    either of the the above statements is reified with
    <em>i</em> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>)))
    using the reification rules in

    <a href="#section-Reification" class="sectionRef"></a>.
    </p>

    <p>If <em>s</em> is empty, no further work is performed.</p>

    <p>For each event <em>n</em> in <em>s</em> and the
    corresponding element event <em>f</em> in <em>l</em>, the following
    statement is added to the graph:</p>

    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code> <em>n</em>.<a href="#eventterm-identifier-string-value">string-value</a>  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#first&gt; <em>f</em>.<a href="#eventterm-identifier-string-value">string-value</a> .</code>
    </p></div></div>

    <p>For each consecutive and overlapping pair of events
    (<em>n</em>, <em>o</em>) in <em>s</em>, the following statement is
    added to the graph:</p>

    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>n</em>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#rest&gt; <em>o</em>.<a href="#eventterm-identifier-string-value">string-value</a>  .</code>

    </p></div></div>

    <p>If <em>s</em> is not empty, <em>n</em> is the last event identifier
    in <em>s</em>, the following statement is added to the graph:</p>
    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>n</em>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#rest&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#nil&gt; .</code>

    </p></div></div>
    </section>

    <!-- parse type other property element -->
    <section id="parseTypeOtherPropertyElt">
    <h4>Production parseTypeOtherPropertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, <a href="#parseOther">parseOther</a>))<br />

    <a href="#propertyEltList">propertyEltList</a><br />
    end-element()
    </p></div></div>


    <p>All <code>rdf:parseType</code> attribute values other than the strings
    "Resource", "Literal" or "Collection" are treated as if the value was
    "Literal".   This production matches and acts as if production
    <a href="#parseTypeLiteralPropertyElt">parseTypeLiteralPropertyElt</a>
    was matched.
    No extra triples are generated for other <code>rdf:parseType</code> values.
    </p>
    </section>

    <!-- empty property element -->
    <section id="emptyPropertyElt">
    <h4>Production emptyPropertyElt</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    start-element(<a href="#eventterm-element-URI">URI</a> == <a href="#propertyElementURIs">propertyElementURIs</a> ),<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-element-attributes">attributes</a> == set(<a href="#idAttr">idAttr</a>?, ( <a href="#resourceAttr">resourceAttr</a> | <a href="#nodeIdAttr">nodeIdAttr</a> | <a href="#datatypeAttr">datatypeAttr</a> )?, <a href="#propertyAttr">propertyAttr</a>*))<br />

    end-element()
    </p></div></div>

    <ul>

    <li>
    <p>If there are no attributes <strong>or</strong> only the
    optional <code>rdf:ID</code> attribute <em>i</em>
    then <em>o</em> := literal(<a href="#eventterm-literal-literal-value">literal-value</a>:="", <a href="#eventterm-literal-literal-language">literal-language</a> := <em>e</em>.<a href="#eventterm-element-language">language</a>)
    and the following statement is added to the graph:</p>

    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> <em>o</em>.<a href="#eventterm-literal-string-value">string-value</a> .</code>

    </p></div></div>

    <p>and then if <em>i</em> is given, the above statement is reified with
    uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>i</em>.<a href="#eventterm-attribute-string-value">string-value</a>)))
    using the reification rules in
    <a href="#section-Reification" class="sectionRef"></a>.</p>

    <p class="note"><strong>Test:</strong>
    Indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test002.rdf">test002.rdf</a>
    and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test002.nt">test002.nt</a>
    </p>

    <p class="note"><strong>Test:</strong>
    Indicated by
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test005.rdf">test005.rdf</a>
    and
    <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test005.nt">test005.nt</a>
    </p>

    </li>

    <li>

    <p>Otherwise</p>

      <ul>
        <li>If <code>rdf:resource</code> attribute <em>i</em> is present, then
        <em>r</em> := uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, <em>i</em>.<a href="#eventterm-attribute-string-value">string-value</a>))
        </li>

        <li>If <code>rdf:nodeID</code> attribute <em>i</em> is present, then
        <em>r</em> := bnodeid(<a href="#eventterm-identifier-identifier">identifier</a> := <em>i</em>.<a href="#eventterm-attribute-string-value">string-value</a>)
        </li>

        <li>If neither,
        <em>r</em> := bnodeid(<a href="#eventterm-identifier-identifier">identifier</a> := generated-blank-node-id())
        </li>
      </ul>

    <p>The following are done in any order:</p>

    <ul>

    <li><p>For all <a href="#propertyAttr">propertyAttr</a>
    attributes <em>a</em> (in any order)</p>
      <ul>

        <li><p>If <em>a</em>.<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:type</code>

        then <em>u</em>:=uri(identifier:=resolve(<em>e</em>, <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>))
        and the following triple is added to the graph:</p>
        <div class="ntripleOuter"><div class="ntripleInner"><p>
        <code><em>r</em>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; <em>u</em>.<a href="#eventterm-identifier-string-value">string-value</a> .</code>

        </p></div></div>
        </li>

        <li><p>Otherwise Unicode string
         <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>
         SHOULD be in Normal Form C [[NFC]],
         <em>o</em> := literal(<a href="#eventterm-literal-literal-value">literal-value</a> := <em>a</em>.<a href="#eventterm-attribute-string-value">string-value</a>, <a href="#eventterm-literal-literal-language">literal-language</a> := <em>e</em>.<a href="#eventterm-element-language">language</a>)
         and the following statement is added to the graph:</p>

        <div class="ntripleOuter"><div class="ntripleInner"><p>
        <code><em>r</em>.<a href="#eventterm-identifier-string-value">string-value</a> <em>a</em>.<a href="#eventterm-attribute-URI-string-value">URI-string-value</a> <em>o</em>.<a href="#eventterm-literal-string-value">string-value</a> .</code>

        </p></div></div>
        </li>

      </ul>

        <p class="note"><strong>Test:</strong>
        Indicated by
        <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test013.rdf">test013.rdf</a>
        and
        <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test013.nt">test013.nt</a>
        </p>

        <p class="note"><strong>Test:</strong>
        Indicated by
        <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test014.rdf">test014.rdf</a>
        and
        <a href="https://w3c.github.io/rdf-tests/rdf-xml/rdfms-empty-property-elements/test014.nt">test014.nt</a>
           </p>

    </li>

    <li><p>Add the following statement to the graph:</p>
      <div class="ntripleOuter"><div class="ntripleInner"><p>
      <code><em>e</em>.parent.<a href="#eventterm-element-subject">subject</a>.<a href="#eventterm-identifier-string-value">string-value</a> <em>e</em>.<a href="#eventterm-element-URI-string-value">URI-string-value</a> <em>r</em>.<a href="#eventterm-identifier-string-value">string-value</a> .</code>

      </p></div></div>

      <p>and then if <code>rdf:ID</code> attribute <em>i</em> is given, the above statement is
      reified with
      uri(<a href="#eventterm-identifier-identifier">identifier</a> := resolve(<em>e</em>, concat("#", <em>i</em>.<a href="#eventterm-identifier-string-value">string-value</a>)))
      using the reification rules in
      <a href="#section-Reification" class="sectionRef"></a>.</p>

    </li>

    </ul>

    </li>
    </ul>
    </section>

    <!-- id attribute -->
    <section id="idAttr">
    <h4 id="idAboutAttr">Production idAttr</h4>
    <!-- idAboutAttr one has gone; id is closest thing replacing it -->

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:ID</code>,<br />

    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == <a href="#rdf-id">rdf-id</a>)
    </p></div></div>

    <p><strong>Constraint:</strong>: <a>constraint-id</a>
    applies to the values of <code>rdf:ID</code> attributes</p>
    </section>

    <!-- node id attribute -->
    <section id="nodeIdAttr">
    <h4>Production nodeIdAttr</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:nodeID</code>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == <a href="#rdf-id">rdf-id</a>)

    </p></div></div>
    </section>

    <!-- about attribute -->
    <section id="aboutAttr">
    <h4>Production aboutAttr</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:about</code>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == <a href="#URI-reference">URI-reference</a>)

    </p></div></div>
    </section>

    <!-- property attribute -->
    <section id="propertyAttr">
    <h4 id="propAttr">Production propertyAttr</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <a href="#propertyAttributeURIs">propertyAttributeURIs</a>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == <a>anyString</a>)

    </p></div></div>
    </section>

    <!-- resource attribute -->
    <section id="resourceAttr">
    <h4>Production resourceAttr</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:resource</code>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == <a href="#URI-reference">URI-reference</a>)

    </p></div></div>
    </section>

    <!-- datatype attribute -->
    <section id="datatypeAttr">
    <h4>Production datatypeAttr</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:datatype</code>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == <a href="#URI-reference">URI-reference</a>)

    </p></div></div>
    </section>

    <!-- parse literal -->
    <section id="parseLiteral">
    <h4>Production parseLiteral</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == "Literal")

    </p></div></div>
    </section>

    <!-- parse resource -->
    <section id="parseResource">
    <h4>Production parseResource</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == "Resource")

    </p></div></div>
    </section>

    <!-- parse collection -->
    <section id="parseCollection">
    <h4>Production parseCollection</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,<br />
    &#160;&#160;&#160;&#160;<a href="#eventterm-attribute-string-value">string-value</a> == "Collection")

    </p></div></div>
    </section>

    <!-- parse other -->
    <section id="parseOther">
    <h4>Production parseOther</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    attribute(<a href="#eventterm-attribute-URI">URI</a> == <code>rdf:parseType</code>,<br />
    &#160;&#160;&#160;&#160;<a
    href="#eventterm-attribute-string-value">string-value</a> == <a>anyString</a> - ("Resource" | "Literal" | "Collection") )

    </p></div></div>
    </section>

    <!-- URI reference -->
    <section id="URI-reference">
    <h4>Production IRI</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    An IRI.
    </p></div></div>
    </section>

    <!-- litteral -->
    <section id="literal">
    <h4>Production literal</h4>

    <div class="productionOuter"><div class="productionInner"><p>

    Any XML element content that is allowed according to
    XML definition <em>Content of Elements</em>
    Rule [43]
    <a data-cite="XML10#NT-content">content</a>.
    in section
    <a data-cite="XML10#sec-starttags">3.1 Start-Tags, End-Tags, and Empty-Element Tags</a>
    </p>

    <p>The string-value for the resulting event is discussed in
    <a  href="#parseTypeLiteralPropertyElt" class="sectionRef"></a>.</p>

    </div></div>
    </section>

    <!-- RDF id -->
    <section id="rdf-id">
    <h4>Production rdf-id</h4>

    <div class="productionOuter"><div class="productionInner"><p>
    An attribute <a href="#eventterm-attribute-string-value" class="termref"><span class="arrow">·</span>string-value<span class="arrow">·</span></a>
    matching any legal
    [[XML-NAMES]] token
    <a data-cite="XML-NAMES#NT-NCName">NCName</a>

    </p></div></div>
    </section>

    </section>

    <!-- reification rules -->
    <section id="section-Reification">
    <h3>Reification Rules</h3>

    <p>For the given IRI event <em>r</em> and
    the statement with terms <em>s</em>, <em>p</em> and <em>o</em>

    corresponding to the N-Triples:</p>
    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>s</em> <em>p</em> <em>o</em>  .</code>
    </p></div></div>

    <p>add the following statements to the graph:</p>
    <div class="ntripleOuter"><div class="ntripleInner"><p>
    <code><em>r</em>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#subject&gt; <em>s</em> .</code><br />

    <code><em>r</em>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate&gt; <em>p</em> .</code><br />
    <code><em>r</em>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#object&gt; <em>o</em> .</code><br />

    <code><em>r</em>.<a href="#eventterm-identifier-string-value">string-value</a> &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement&gt; .</code><br />
    </p></div></div>
    </section>

    <!-- expansion rules -->
    <section id="section-List-Expand">
    <h3>List Expansion Rules</h3>

    <p>For the given element <em>e</em>, create a new IRI <em>u</em> :=
    concat("http://www.w3.org/1999/02/22-rdf-syntax-ns#_",

    <em>e</em>.<a href="#eventterm-element-liCounter">li-counter</a>),
    increment the
    <em>e</em>.<a href="#eventterm-element-liCounter">li-counter</a>
    property by 1 and return <em>u</em>.</p>
    </section>

</section>

<!-- SEVENTH PART : serialising -->
<section id="section-Serialising">
    <h2>Serializing an RDF Graph to RDF/XML</h2>

    <p>There are some RDF Graphs as defined in
    [[RDF12-CONCEPTS]]that cannot be serialized in RDF/XML. These are those that:</p>

    <dl>
      <dt>Use property names that cannot be turned into XML namespace-qualified names.<br /></dt>
      <dd>An XML namespace-qualified name
      (<a data-cite="XML-NAMES/#ns-qualnames">QName</a>)
      has restrictions on the legal characters such that not all property URIs
      can be expressed as these names.
      It is recommended that implementors of RDF serializers, in order to
      break a URI into a namespace name and a local name, split it after
      the last XML non-<a data-cite="XML-NAMES/#NT-NCName">NCName</a>
      character, ensuring that the first character of the name is a
      <a data-cite="XML10#NT-Letter">Letter</a> or '_'.
      If the URI ends in a
      non-<a data-cite="XML-NAMES/#NT-NCName">NCName</a>
      character then throw a "this graph cannot be serialized in RDF/XML"
      exception or error.
      </dd>

      <dt>Use inappropriate reserved names as properties<br /></dt>
      <dd>For example, a property with the same URI as any of the
      <a href="#syntaxTerms">syntaxTerms</a> production.
      </dd>

      <dt>Use the <code>rdf:HTML</code> datatype</dt>
      <dd>This datatype as introduced in RDF 1.2 [[RDF12-CONCEPTS]].</dd>

    </dl>

    <p class="note"><strong>Implementation Note (Informative):</strong>
    When an RDF graph is serialized to RDF/XML and has an XML Schema
    Datatype (XSD), it SHOULD be written in a form that does not require
    whitespace processing.  XSD support is NOT required by RDF or RDF/XML
    so this is optional.
    </p>
</section>


<!-- NINETH PART : RDF XML with SVG -->
<section id="section-rdf-in-SVG" class="informative">
    <h2>Using RDF/XML with SVG</h2>

    <p>There is a standardized approach for associating RDF compatible
    metadata with SVG &mdash; the metadata element which was explicitly
    designed for this purpose as defined in
    <a data-cite="SVG10/metadata.html#">Section 21 Metadata</a>

    of the [[[SVG10]]] [[SVG10]]
    and [[[SVG11]]] [[SVG11]].
  </p>

    <p>This document contains two example graphs in SVG with such
    embedded RDF/XML inside the metadata element:
    <a href="figure1.svg">figure 1</a> and <a href="figure2.svg">figure 2</a>.</p>
</section>

<!-- TENTH PART : Acknowledgments -->
<section id="section-Acknowledgments" class="appendix informative">
  <h2>Acknowledgments</h2>

  <section class="informative">
    <h3>Acknowledgments the original specification</h3>


    <p>This document is a product of extended deliberations by the RDF
    Core working group, whose members have included: Art Barstow (W3C)
    Dave Beckett (ILRT), Dan Brickley (W3C/ILRT), Dan Connolly (W3C),
    Jeremy Carroll (Hewlett Packard), Ron Daniel (Interwoven Inc), Bill
    dehOra (InterX), Jos De Roo (AGFA), Jan Grant (ILRT), Graham Klyne
    (Clearswift and Nine by Nine), Frank Manola (MITRE Corporation),
    Brian McBride (Hewlett Packard), Eric Miller (W3C), Stephen
    Petschulat (IBM), Patrick Stickler (Nokia), Aaron Swartz (HWG), Mike
    Dean (BBN Technologies / Verizon), R. V. Guha (Alpiri Inc), Pat Hayes
    (IHMC), Sergey Melnik (Stanford University), Martyn Horner (Profium
    Ltd).</p>

    <p>This specification also draws upon an earlier RDF Model and Syntax
    document edited by Ora Lassilla and Ralph Swick, and RDF Schema
    edited by Dan Brickley and R. V. Guha. RDF and RDF Schema Working
    group members who contributed to this earlier work are:
    Nick Arnett (Verity), Tim Berners-Lee (W3C), Tim Bray (Textuality),
    Dan Brickley (ILRT / University of Bristol), Walter Chang (Adobe),
    Sailesh Chutani (Oracle), Dan Connolly (W3C), Ron Daniel
    (DATAFUSION), Charles Frankston (Microsoft), Patrick Gannon
    (CommerceNet), RV Guha (Epinions, previously of Netscape
    Communications), Tom Hill (Apple Computer), Arthur van Hoff
    (Marimba), Renato Iannella (DSTC), Sandeep Jain (Oracle), Kevin
    Jones, (InterMind), Emiko Kezuka (Digital Vision Laboratories), Joe
    Lapp (webMethods Inc.), Ora Lassila (Nokia Research Center), Andrew
    Layman (Microsoft), Ralph LeVan (OCLC), John McCarthy (Lawrence
    Berkeley National Laboratory), Chris McConnell (Microsoft), Murray
    Maloney (Grif), Michael Mealling (Network Solutions), Norbert Mikula
    (DataChannel), Eric Miller (OCLC), Jim Miller (W3C, emeritus), Frank
    Olken (Lawrence Berkeley National Laboratory), Jean Paoli
    (Microsoft), Sri Raghavan (Digital/Compaq), Lisa Rein (webMethods
    Inc.), Paul Resnick (University of Michigan), Bill Roberts
    (KnowledgeCite), Tsuyoshi Sakata (Digital Vision Laboratories), Bob
    Schloss (IBM), Leon Shklar (Pencom Web Works), David Singer (IBM),
    Wei (William) Song (SISU), Neel Sundaresan (IBM), Ralph Swick (W3C),
    Naohiko Uramoto (IBM), Charles Wicksteed (Reuters Ltd.), Misha Wolf
    (Reuters Ltd.), Lauren Wood (SoftQuad).
    </p>
  </section>

  <section class="informative">
    <h3>Acknowledgments for RDF 1.1</h3>

    <p>Gavin Carothers provided the RDF 1.1 update for the <a
    href="#parseTypeLiteralPropertyElt">Production
    parseTypeLiteralPropertyElt</a>. Ivan Herman provided valuable
    comments and reworked Figs 1 and 2. </p>

    <p>This specification is a product of extended deliberations by the
    members of the RDFcore Working Group and the RDF and RDF Schema Working Group.</p>

    <p>The following people provided valuable contributions to the document:</p>

    <ul>
      <li>Dan Brickley, W3C/ILRT</li>
      <li>Jeremy Carroll, HP Labs, Bristol</li>
      <li>Graham Klyne, Nine by Nine</li>
      <li>Bijan Parsia, MIND Lab at University of Maryland at College Park</li>
    </ul>
  </section>

  <section class="informative">
    <h3>Acknowledgments for RDF 1.2</h3>

    <p>In addition to the editors, the following people have contributed to this specification:
      <span id="gh-contributors"></span>
    </p>

    <p data-include="common/participants.html"></p>

    <p class="ednote">Recognize members of the Task Force? Not an easy to find list of contributors.</p>
  </section>
</section>

<section class="appendix informative" id="changes-12">
  <h2>Changes between RDF 1.1 and RDF 1.2</h2>

  <ul>
    <li>Adds <a href="#privacy-considerations"></a> and <a href="#security"></a>.</li>
  </ul>
</section>

<!-- TWELVETH PART : Syntax Schemas -->
<section id="section-Schemas" class="appendix informative">
    <h2>Syntax Schemas</h2>

    <p>This appendix contains XML schemas for validating RDF/XML forms.
    These are example schemas for information only and are not part of
    this specification.</p>

    <!-- Compact Schema -->
    <section id="section-RELAXNG-Schema" class="informative">
    <h3>RELAX&#160;NG Compact Schema</h3>

    <p>This is an <a
    href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/rdfxml.rnc">example
    schema in
    RELAX&#160;NG Compact</a> (for ease of reading)
    for RDF/XML.   Applications can also use the
    <a href="https://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/rdfxml.rng">RELAX&#160;NG XML version</a>.
    These formats are described in
    RELAX&#160;NG [[RELAXNG]]
    and RELAX&#160;NG Compact [[RELAXNG-COMPACT]].</p>

    <p class="note">
    The RNGC schema has been updated to attempt to match the grammar but
    this has not been checked or used to validate RDF/XML.
    </p>

    <pre>
    #
    # RELAX NG Compact Schema for RDF/XML Syntax
    #
    # This schema is for information only and NON-NORMATIVE
    #
    # It is based on one originally written by James Clark in
    # http://lists.w3.org/Archives/Public/www-rdf-comments/2001JulSep/0248.html
    # and updated with later changes.
    #

    namespace local = ""
    namespace rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"

    start = doc

    # I cannot seem to do this in RNGC so they are expanded in-line

    # coreSyntaxTerms = rdf:RDF | rdf:ID | rdf:about | rdf:parseType | rdf:resource | rdf:nodeID | rdf:datatype
    # syntaxTerms = coreSyntaxTerms | rdf:Description | rdf:li
    # oldTerms    = rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID
    # nodeElementURIs       = * - ( coreSyntaxTerms | rdf:li | oldTerms )
    # propertyElementURIs   = * - ( coreSyntaxTerms | rdf:Description | oldTerms )
    # propertyAttributeURIs = * - ( coreSyntaxTerms | rdf:Description | rdf:li | oldTerms )

    # Also needed to allow rdf:li on all property element productions
    # since we can't capture the rdf:li rewriting to rdf_&lt;n&gt; in relaxng

    # Need to add these explicitly
    xmllang = attribute xml:lang { text }
    xmlbase = attribute xml:base { text }
    # and to forbid every other xml:* attribute, element

    doc =
      RDF | nodeElement

    RDF =
      element rdf:RDF {
         xmllang?, xmlbase?, nodeElementList
    }

    nodeElementList =
      nodeElement*

      # Should be something like:
      #  ws* , (  nodeElement , ws* )*
      # but RELAXNG does this by default, ignoring whitespace separating tags.

    nodeElement =
      element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                    rdf:resource | rdf:nodeID | rdf:datatype | rdf:li |
                    rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID ) {
          (idAttr | nodeIdAttr | aboutAttr )?, xmllang?, xmlbase?, propertyAttr*, propertyEltList
      }

      # It is not possible to say "and not things
      # beginning with _ in the rdf: namespace" in RELAX NG.

    ws =
      " "

      # Not used in this RELAX NG schema; but should be any legal XML
      # whitespace defined by http://www.w3.org/TR/2000/REC-xml-20001006#NT-S


    propertyEltList =
      propertyElt*

      # Should be something like:
      #  ws* , ( propertyElt , ws* )*
      # but RELAXNG does this by default, ignoring whitespace separating tags.

    propertyElt =
      resourcePropertyElt |
      literalPropertyElt |
      parseTypeLiteralPropertyElt |
      parseTypeResourcePropertyElt |
      parseTypeCollectionPropertyElt |
      parseTypeOtherPropertyElt |
      emptyPropertyElt

    resourcePropertyElt =
      element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                    rdf:resource | rdf:nodeID | rdf:datatype |
                    rdf:Description | rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID |
                    xml:* ) {
          idAttr?, xmllang?, xmlbase?, nodeElement
      }

    literalPropertyElt =
      element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                    rdf:resource | rdf:nodeID | rdf:datatype |
                    rdf:Description | rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID |
                    xml:* ) {
          idAttr? , datatypeAttr?, xmllang?, xmlbase?, text
      }

    parseTypeLiteralPropertyElt =
      element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                    rdf:resource | rdf:nodeID | rdf:datatype |
                    rdf:Description | rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID |
                    xml:* ) {
          idAttr?, parseLiteral, xmllang?, xmlbase?, literal
      }

    parseTypeResourcePropertyElt =
      element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                    rdf:resource | rdf:nodeID | rdf:datatype |
                    rdf:Description | rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID |
                    xml:* ) {
          idAttr?, parseResource, xmllang?, xmlbase?, propertyEltList
      }

    parseTypeCollectionPropertyElt =
      element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                    rdf:resource | rdf:nodeID | rdf:datatype |
                    rdf:Description | rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID |
                    xml:* ) {
          idAttr?, xmllang?, xmlbase?, parseCollection, nodeElementList
      }

    parseTypeOtherPropertyElt =
      element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                    rdf:resource | rdf:nodeID | rdf:datatype |
                    rdf:Description | rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID |
                    xml:* ) {
          idAttr?, xmllang?, xmlbase?, parseOther, any
      }

    emptyPropertyElt =
       element * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                     rdf:resource | rdf:nodeID | rdf:datatype |
                     rdf:Description | rdf:aboutEach | rdf:aboutEachPrefix | rdf:bagID |
                     xml:* ) {
           idAttr?, (resourceAttr | nodeIdAttr | datatypeAttr )?, xmllang?, xmlbase?, propertyAttr*
       }

    idAttr =
      attribute rdf:ID {
          IDsymbol
      }

    nodeIdAttr =
      attribute rdf:nodeID {
          IDsymbol
      }

    aboutAttr =
      attribute rdf:about {
          URI-reference
      }

    propertyAttr =
      attribute * - ( local:* | rdf:RDF | rdf:ID | rdf:about | rdf:parseType |
                      rdf:resource | rdf:nodeID | rdf:datatype | rdf:li |
                      rdf:Description | rdf:aboutEach |
              rdf:aboutEachPrefix | rdf:bagID |
                      xml:* ) {
          string
      }

    resourceAttr =
      attribute rdf:resource {
          URI-reference
      }

    datatypeAttr =
      attribute rdf:datatype {
          URI-reference
      }

    parseLiteral =
      attribute rdf:parseType {
          "Literal"
      }

    parseResource =
      attribute rdf:parseType {
          "Resource"
      }

    parseCollection =
      attribute rdf:parseType {
          "Collection"
      }

    parseOther =
      attribute rdf:parseType {
          text
      }

    URI-reference =
      string

    literal =
      any

    IDsymbol =
      xsd:NMTOKEN

    any =
      mixed { element * { attribute * { text }*, any }* }
    </pre>

    </section>
</section>

<section id="index"></section>

</body>
</html>
